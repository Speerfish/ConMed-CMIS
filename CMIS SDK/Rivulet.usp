/*********************************************************************************
  Compiler Directives
  (Uncomment and declare compiler directives as needed)
*********************************************************************************/
// #SYMBOL_NAME ""
// #HINT ""
// #DEFINE_CONSTANT

// INFO - Sample XML Tags...

#DEFINE_CONSTANT XML_MAX_TAGS  		100

#DEFINE_CONSTANT XML_ID_CONFIG  		1
#DEFINE_CONSTANT XML_ID_VERSION  		2
#DEFINE_CONSTANT XML_ID_PRODUCTNAME  	3
#DEFINE_CONSTANT XML_ID_PRODUCTVER  	4
#DEFINE_CONSTANT XML_ID_SITENAME  		5
#DEFINE_CONSTANT XML_ID_CONFIGNUM  		6
#DEFINE_CONSTANT XML_ID_CONFERENCING  	7
#DEFINE_CONSTANT XML_ID_CONFSTART  		8
#DEFINE_CONSTANT XML_ID_CONFACCEPT  	9
#DEFINE_CONSTANT XML_ID_PERMISSION  	10
#DEFINE_CONSTANT XML_ID_ITEM  			11
#DEFINE_CONSTANT XML_ID_TYPE  			12
#DEFINE_CONSTANT XML_ID_CLASS			13
#DEFINE_CONSTANT XML_ID_PORT 			14
#DEFINE_CONSTANT XML_ID_SVIDEOIN  		15
#DEFINE_CONSTANT XML_ID_SVIDEOOUT  		16  

#DEFINE_CONSTANT MAX_ROUTES      4
#DEFINE_CONSTANT MAX_ID_LENGTH  20

//CurRqst values
#DEFINE_CONSTANT RQST_IDLE              0
#DEFINE_CONSTANT RQST_CONNECT           1
#DEFINE_CONSTANT RQST_DISCONNECT        2
#DEFINE_CONSTANT RQST_PORTSTATUS        3

//CurStatus values
#DEFINE_CONSTANT RIVULET_IDLE           0
#DEFINE_CONSTANT RIVULET_CONNECTING     1
#DEFINE_CONSTANT RIVULET_CONNECTED      2
#DEFINE_CONSTANT RIVULET_DISCONNECTING  3
#DEFINE_CONSTANT RIVULET_DISCONNECTED   4
#DEFINE_CONSTANT RIVULET_ERROR          5  

//Connect Type  
#DEFINE_CONSTANT TYPE_NONE              0
#DEFINE_CONSTANT TYPE_HVPTOHVP          1
#DEFINE_CONSTANT TYPE_HVPTOVEC          2

//Endpoint Type
#DEFINE_CONSTANT ENDPOINT_VEC               1
#DEFINE_CONSTANT ENDPOINT_HVP               2 

//XML Receive
#DEFINE_CONSTANT RESPONSE_LIST_MAX         20  

#DEFINE_CONSTANT RIVULET_LOGIN_SUCCESS_MSG              "login-success" 
#DEFINE_CONSTANT RIVULET_GET_PORT_STATUS_MSG            "get-ep-port-alias-status-success" 
#DEFINE_CONSTANT RIVULET_CONNECT_SERVICE_FAILURE_MSG    "connect-service-failure"  
#DEFINE_CONSTANT RIVULET_CONNECT_SERVICE_SUCCESS_MSG    "connect-service-success"
#DEFINE_CONSTANT RIVULET_DISCONNECT_SERVICE_FAILURE_MSG "disconnect-service-failure"
#DEFINE_CONSTANT RIVULET_DISCONNECT_SERVICE_SUCCESS_MSG "disconnect-service-success"
//BOOLEAN
#DEFINE_CONSTANT TRUE	1
#DEFINE_CONSTANT FALSE  0

/*********************************************************************************
  Include Libraries
  (Uncomment and include additional librarys as needed)
*********************************************************************************/
// #CRESTRON_LIBRARY ""

#USER_LIBRARY "CMIS_Hub_Library"
#USER_LIBRARY "CMIS_Hub_XML"

/*******************************************************************************************
  DIGITAL, ANALOG and SERIAL INPUTS and OUTPUTS
  (Uncomment and declare inputs and outputs as needed)
*******************************************************************************************/

// Inputs
// DIGITAL_INPUT 

// INFO - DIGITAL inputs can take on the values of 0 or 1.
//        When they go high, it's an event that will start a "process" running.

DIGITAL_INPUT   sigStartupComplete;  //INFO - Event we will use to start "background" task
                                     //       of always-running Rivulet control code. 
DIGITAL_INPUT	sigRivuletConnected; //INFO - Indication of Rivulet TCP/IP connection...
                                     //       Tx/Rx streams will be allowed to go through to the Rivulet control port.
                                     //       If this signal is "low", there is no need to send Tx streams. 

DIGITAL_INPUT   diDebug;

// ANALOG_INPUT  
ANALOG_INPUT    aiRivLinkStatus;

// STRING_INPUT	
STRING_INPUT 	RxRivulet[255];   //INFO - Rivulet Rx Data stream
STRING_INPUT	siRivuletConfig[255];   //INFO - Configuration data for an endpoint should tell us about the two endpoints.
STRING_INPUT	siVidRoute[255];  //INFO - Message rcv'd from Hub call control module when a connection
                                  //       is made or disconnected.

// Outputs
// DIGITAL_OUTPUT 
DIGITAL_OUTPUT  doRivLinkEnable;

// ANALOG_OUTPUT 

// STRING_OUTPUT
STRING_OUTPUT	TxRivulet;       // INFO - Rivulet Tx Data stream

ANALOG_OUTPUT   aoEndpointStatus[MAX_ENDPOINTS];

/*******************************************************************************************
  Structure Definitions
  (Uncomment and define structure definitions as needed)
  Note:  Be sure to initialize all declared STRING variables as needed
         For example, in Function Main: struct.myString = "";
*******************************************************************************************/

// INFO Keep structure for now, don't think we'll need it though...
STRUCTURE VideoEndpoint
{
	INTEGER CustomEndpointID;	// 0 if not a custom endpoint, value 1-4 otherwise.
	INTEGER FixedEndpointID;	// 0 if not a fixed endpoint, value 1-MAX_FIXED_ENDPOINTS otherwise. 

    INTEGER Status[4];
	INTEGER SVideoInCount;	
	INTEGER SVideoOutCount;	
	INTEGER SVideoInStart; 
	INTEGer SVideoOutStart; 
	
	INTEGER RivAudioInCnt;
	INTEGER RivAudioOutCnt;
	INTEGER RivDVIInCnt;	
	INTEGER RivDVIOutCnt;	
	INTEGER RivSVideoInCnt;	
	INTEGER RivSVideoOutCnt;	
	INTEGER RivEndpointType;   //HVP or VEC
	STRING  RivVEC_IP[20];     //If VEC, this is the IP Address	
	
	INTEGER Privacy;
}; 

STRUCTURE Connection
{
    INTEGER Room1;        //Endpoint 1
    INTEGER Room2;        //Endpoint 2
    INTEGER CurRqst;      //Connection Request - may be set RQST_CONNECT, or RQST_DISCONNECT by sVidRoute
                          //                     set RQST_IDLE by Rivulet processing. 
    INTEGER CurStatus;    //Rivulet processing Status.  RIVULET_IDLE, RIVULET_CONNECTING, RIVULET_DISCONNECTING...  PG:  RIVULET_ERROR
    STRING  ErrorString[200];
    INTEGER AudioCnt;
    INTEGER DVICnt;
    INTEGER SVideoCnt;
    INTEGER TYPE; 
    STRING  VEC_IP[20];
    STRING  CorrelationID1[MAX_ID_LENGTH];
    STRING  CorrelationID2[MAX_ID_LENGTH];
    STRING  CorrelationID3[MAX_ID_LENGTH];
    STRING  CorrelationID4[MAX_ID_LENGTH];
    STRING  ServiceID1[MAX_ID_LENGTH]; 
    STRING  ServiceID2[MAX_ID_LENGTH]; 
    STRING  ServiceID3[MAX_ID_LENGTH]; 
    STRING  ServiceID4[MAX_ID_LENGTH]; 
};
 
STRUCTURE ResponseData
{
    STRING COORELATIONID[20];
    STRING SERVICEID[20];
    STRING API_CMD_RESP[50];
    STRING API_CMD_ERROR[100];
    STRING ENDPOINT_ALIAS[20]; 
    STRING ENDPOINT_STATUS[20];
    INTEGER INUSE;
};

Connection ConnectionList[MAX_ENDPOINTS];
VideoEndpoint Endpoints[MAX_ENDPOINTS];

// Receive 
ResponseData ResponseList[RESPONSE_LIST_MAX];
string gsResponseMsg[1024];

// INFO - DELETE?
// constructed in conferencehub, needs to be used here
STRUCTURE FIXED_ENDPOINT
{
	INTEGER Source[MAX_FIXED_SOURCES];
	INTEGER Target[MAX_FIXED_TARGETS];
};

// INFO - DELETE?
FIXED_ENDPOINT FixedRoutingTable[MAX_FIXED_ENDPOINTS];

/*******************************************************************************************
  Global Variables
*******************************************************************************************/

//-----------------------------------------------------------------------------
// XML Data 

// INFO - normally when CMIS is reading XML, it is data coming from a file
//        that establishes the configuration of our system.  These are
//        used with the xml functions in the usl library file.

string  gsXmlStrings[XML_STRING_ARRAY_SIZE][XML_BUFFER_SIZE];
integer giXmlData[XML_DATA_ARRAY_SIZE];
string  gsXmlParams[4096];
string  gsXmlFileTags[XML_MAX_TAGS][64];  

// INFO - Code I "borrowed" is "debouncing the TCP/IP connection... I need to check on this.
integer giConnectedToRivulet;  // INFO - Rivulet connection status... in case TCP/IP goes down...
integer gInhibitBounce;       // INFO - ok... use this too  
integer giRivuletReady; 
integer giRivuletConfigured;     

// Rivulet Communication Vars
integer giRivuletCoorID;   
string  gsRivuletSessionID[50];

		
/*******************************************************************************************
  Functions
*******************************************************************************************/

/****************************************************
 This function will get the coorelation id for the
 specified connection and dviid.
*****************************************************/

STRING_FUNCTION getConnectionCoorID( integer connectionid, integer dviid )
{  
    string conCoorID[20];
    conCoorID = "";
    
    if ( dviid = 1 )
    {
        conCoorID = ConnectionList[connectionid].CorrelationID1;
    }
    else if ( dviid = 2 )
    {
        conCoorID = ConnectionList[connectionid].CorrelationID2;
    }
    else if ( dviid = 3 )
    {
        conCoorID = ConnectionList[connectionid].CorrelationID3;
    }
    else if ( dviid = 4 )
    { 
        conCoorID = ConnectionList[connectionid].CorrelationID4;
    } 
    return(conCoorID);   
}

 

/****************************************************
 This function will set the coorelation id for the
 specified connection and dviid.
*****************************************************/

function setConnectionCoorID( integer connectionid, integer dviid, string coorid )
{     
    if ( dviid = 1 )
    {
        ConnectionList[connectionid].CorrelationID1 = coorid;
    }
    else if ( dviid = 2 )
    {
        ConnectionList[connectionid].CorrelationID2 = coorid;
    }
    else if ( dviid = 3 )
    {
        ConnectionList[connectionid].CorrelationID3 = coorid;
    }
    else if ( dviid = 4 )
    { 
        ConnectionList[connectionid].CorrelationID4 = coorid;
    } 
} 

/****************************************************
 This function will get the service id for the
 specified connection and dviid.
*****************************************************/

STRING_FUNCTION getConnectionServiceID( integer connectionid, integer dviid )
{ 
    string conServiceID[20];
    conServiceID = "";
    
    if ( dviid = 1 )
    {
        conServiceID = ConnectionList[connectionid].ServiceID1;
    }
    else if ( dviid = 2 )
    {
        conServiceID = ConnectionList[connectionid].ServiceID2;
    }
    else if ( dviid = 3 )
    {
        conServiceID = ConnectionList[connectionid].ServiceID3;
    }
    else if ( dviid = 4 )
    { 
        conServiceID = ConnectionList[connectionid].ServiceID4;
    } 
    return(conServiceID);  
}

/****************************************************
 This function will set the service id for the
 specified connection and dviid.
*****************************************************/

function setConnectionServiceID( integer connectionid, integer dviid, string serviceid )
{ 
    if ( dviid = 1 )
    {
        ConnectionList[connectionid].ServiceID1 = serviceid;
    }
    else if ( dviid = 2 )
    {
        ConnectionList[connectionid].ServiceID2 = serviceid;
    }
    else if ( dviid = 3 )
    {
        ConnectionList[connectionid].ServiceID3 = serviceid;
    }
    else if ( dviid = 4 )
    { 
        ConnectionList[connectionid].ServiceID4 = serviceid;
    }   
}   

integer_function StoreServiceID( string corrid, string serviceid)
{
    integer connectionid; 
    integer found;

    found = off;    
    
    for (connectionid = 1 to MAX_ENDPOINTS)
    {
        if (find(corrid, ConnectionList[connectionid].CorrelationID1))
        {
            ConnectionList[connectionid].ServiceID1 = serviceid;
            found = on;
        }
        else if (find(corrid, ConnectionList[connectionid].CorrelationID2))
        {
            ConnectionList[connectionid].ServiceID2 = serviceid;
            found = on;
        }
        else if (find(corrid, ConnectionList[connectionid].CorrelationID3))
        {
            ConnectionList[connectionid].ServiceID3 = serviceid;
            found = on;
        }
        else if (find(corrid, ConnectionList[connectionid].CorrelationID4))
        {
            ConnectionList[connectionid].ServiceID4 = serviceid;
            found = on;
        }
        
        if (found)
            return(connectionid);
    }
    
    return(0);
}    
    


/****************************************************
 This function will send data to the RCAS server over the
 available TCP connection.  This function will split up the
 send into 160 byte chunks as Crestron cannot handle more.
 *****************************************************/
 
function sendData( string xmlData )
{ 
    // Can only send 255 bytes at a time 
    integer length; 
    string sendString[160];
    string tmpString[1024];
    tmpString = xmlData;
    while(1)	
	{
	    length = len(tmpString);
	    if (length > 160)
	    {
	        sendString = RemoveByLength(160, tmpString);
	        TxRivulet = sendString; 
            //* DEBUG */ print( "Sending To Rivulet:  %s len=%d\n", sendString, len(sendString) ); 
            processlogic();            
	    }
	    else
	    {
	        sendstring = tmpstring;
	        TxRivulet = sendString; 
	        //* DEBUG */ print( "Sending Last To Rivulet:  %s\n", sendString );
	        break;
	    }   
	}
}
     
/****************************************************
 This function returns a unique coorelation ID to match 
 Rivulet API requests with Rivulet API responses.
*****************************************************/

STRING_FUNCTION getCoorID()
{
    if ( giRivuletCoorid = 65535 )
    {
        giRivuletCoorid = 1;
    } 
    else
    {
        giRivuletCoorid = giRivuletCoorid + 1; 
    }
    return( itoa( giRivuletCoorid ));
}  

/****************************************************
 This function returns clears out the connection list.
 This is called at system startup and when a connection
 to the RCAS server is lost.
 *****************************************************/

function ClearConnection(integer i)
{
    
    ConnectionList[i].Room1 = 0; 				        
    ConnectionList[i].Room2 = 0;        	
    ConnectionList[i].CurRqst = RQST_IDLE;        
    ConnectionList[i].CurStatus = RIVULET_IDLE;    					
    ConnectionList[i].ErrorString = "";
    ConnectionList[i].AudioCnt = 0;
    ConnectionList[i].DVICnt = 0;
    ConnectionList[i].SVideoCnt = 0;
    ConnectionList[i].TYPE = TYPE_NONE; 
    ConnectionList[i].VEC_IP = "";
    ConnectionList[i].CorrelationID1 = "";
    ConnectionList[i].CorrelationID2 = "";
    ConnectionList[i].CorrelationID3 = "";
    ConnectionList[i].CorrelationID4 = "";
    ConnectionList[i].ServiceID1 = ""; 
    ConnectionList[i].ServiceID2 = ""; 
    ConnectionList[i].ServiceID3 = ""; 
    ConnectionList[i].ServiceID4 = "";  
    
    aoEndpointStatus[i] = RIVULET_IDLE;
}

function clearConnectionList()
{
    integer i;
    
    for( i = 1 to MAX_ENDPOINTS )
    {  
        ClearConnection( i );
    }
 } 

function clearResponse( integer i )
{
    ResponseList[i].COORELATIONID = "";
    ResponseList[i].SERVICEID = "";
    ResponseList[i].API_CMD_RESP = "";
    ResponseList[i].API_CMD_ERROR = "";
    ResponseList[i].ENDPOINT_ALIAS = "";
    ResponseList[i].ENDPOINT_STATUS = "";
    ResponseList[i].INUSE = FALSE;
} 

function clearResponseList()
{ 
    integer i;
    for ( i = 1 to RESPONSE_LIST_MAX )
    {
        ClearResponse(i);
    }
}

INTEGER_FUNCTION getUnusedResponse()
{ 
    integer i;
    for ( i = 1 to RESPONSE_LIST_MAX )
    {
        if ( ResponseList[i].INUSE = FALSE )
        {
            return( i );
        }
    }
    return( 0 );
}

INTEGER_FUNCTION getResponseByCoorID( string coorid )
{
    integer i;
    for ( i = 1 to RESPONSE_LIST_MAX )
    {
        if ( ResponseList[i].COORELATIONID = coorid )
        {
            if (ResponseList[i].INUSE = TRUE) // don't let it be used if the msg has not yet been flagged "in use"
                return( i );
        }
    }
    return( 0 );
}


/*******************************************************************************************
  Autopatch Functions
  If it writes to TxRivulet, TxRGB, or TxHD, it belongs here
*******************************************************************************************/

// INFO - leaving the functions around as samples...  could be useful...

function EnableSVideo(integer i, integer o)
{
	string outString[16];
	makestring(outString,"CL1I%02dO%02dT",i,o);
	TxRivulet = outString;
	//*DEBUG*/print("SVideo enable %d %d <%s>\n",i,o,outString);
}

//-----------------------------------------------------------------------------

function DisableSVideo(integer o)
{
	string outString[16];
	makestring(outString,"DL1O%02dT",o);
	TxRivulet = outString;
	//*DEBUG*/print("SVideo disable %d, <%s>\n",o,outString);
}

//-----------------------------------------------------------------------------



/*******************************************************************************************
  Routing Functions
*******************************************************************************************/




//-----------------------------------------------------------------------------

function RoutingEnable(integer endpoint1, integer endpoint2)
{
    integer i, availConnection;

    availConnection = 0;
        
    for (i=1 to MAX_ENDPOINTS)
    {
        if (ConnectionList[i].CurStatus = RIVULET_IDLE) 
        {
            availConnection = i;
            break;
        }
    }
    
    if (availConnection = 0)
    {
        print("No Available connections\n");
        return;                            
    }

    if (Endpoints[endpoint1].RivEndpointType = ENDPOINT_VEC)
    {
        ConnectionList[availConnection].Room1 = endpoint2;
        ConnectionList[availConnection].Room2 = endpoint1;
        ConnectionList[availConnection].Type = TYPE_HVPTOVEC;
    }
    
    else if (Endpoints[endpoint2].RivEndpointType = ENDPOINT_VEC)    
    {
        ConnectionList[availConnection].Room1 = endpoint1;
        ConnectionList[availConnection].Room2 = endpoint2;
        ConnectionList[availConnection].Type = TYPE_HVPTOVEC;
    } 
    
    else
    {
        ConnectionList[availConnection].Room1 = endpoint1;
        ConnectionList[availConnection].Room2 = endpoint2;
        ConnectionList[availConnection].Type = TYPE_HVPTOHVP;
    }
    
    ConnectionList[availConnection].AudioCnt  = Endpoints[endpoint1].RivAudioInCnt;   
    ConnectionList[availConnection].DVICnt    = Endpoints[endpoint1].RivDVIInCnt;   
    ConnectionList[availConnection].SVideoCnt = Endpoints[endpoint1].RivSVideoInCnt;   

    ConnectionList[availConnection].VEC_IP = Endpoints[endpoint1].RivVec_ip;   
    
    ConnectionList[availConnection].CurRqst   = RQST_CONNECT; 

    print("Connection Request submitted to Rivulet, endpoint %i to endpoint %i, Connection id %i\n",
           ConnectionList[availConnection].Room1,
           ConnectionList[availConnection].Room2, availConnection);
}

//-----------------------------------------------------------------------------

function RoutingDisable(integer endpoint1, integer endpoint2)
{
    integer i, CurConnection;
    
    CurConnection = 0;
        
    for (i=1 to MAX_ENDPOINTS)
        if (ConnectionList[i].CurStatus <> RIVULET_IDLE)
            if ((ConnectionList[i].Room1 = endpoint1) || (ConnectionList[i].Room2 = endpoint1))
            {
                CurConnection = i;
                break;
            }
    
    if (CurConnection = 0)
    {
        print("Connection not found for endpoints %d, %d\n", endpoint1, endpoint2);
    }
    else
    {
        ConnectionList[CurConnection].CurRqst = RQST_DISCONNECT;
            
        print("Connection Disconnect submitted to Rivulet, endpoint %d to endpoint %d, Connection id %d\n", 
           ConnectionList[CurConnection].Room1,
           ConnectionList[CurConnection].Room2, CurConnection);
    }
}

//-----------------------------------------------------------------------------

function InitializeIO()
{
	integer i,j,k;
	integer index;
	integer length;
	integer simCount;
	
	simCount = 0;
	
	// Initialize all room routings
	for (i = 1 to MAX_ENDPOINTS)
	{
		// Initialize SVideo output routes
		index = Endpoints[i].SVideoOutStart;
		length = Endpoints[i].SVideoOutCount;
		if (length)
		{
			print("Hub: Initialize, Endpoint %d, disable svideo %2d through %2d\n",i,index,index + length -1);
			for (j = index to index + length - 1)
			{
			  DisableSVideo(j);
			}
		}

	}

	print("Hub: Video Initialization complete\n");
}  
 

STRING_FUNCTION getAttributeValue( string xmlNodeName, string attributeName, string xml )
 {  
     string tmpstring[1024], tmpnodename[255], rmtmpstring[1024], attributeValue[255];
     integer position,svalpos,evalpos,attrvallen;
     tmpstring = xml;
     tmpnodename = "<" + xmlNodeName;
     position = Find( tmpnodename, tmpstring, 1 );
     // If node is not found get out
     if ( position = 0 ) return( "" );
     position = position + len(tmpnodename);
     rmtmpstring = RemoveByLength( position, tmpstring);
     position = Find( attributeName, tmpstring, 1 ); 
     // Really need to extract ONLY the XML node and then 
     // search. 
     if ( position = 0 ) return ( "" );
     position = Find( "\x22", tmpstring, position );
     svalpos = position;
     position = Find( "\x22", tmpstring, position+1);
     evalpos = position;
     //* DEBUG */ print( "getAttributeValue  svalpos=%d, evalpos=%d, tmpstring=%s\n", svalpos, evalpos, tmpstring);
     attrvallen = evalpos - svalpos - 1; 
     attributeValue = Mid(tmpstring, svalpos+1, attrvallen );
     //* DEBUG */ print( "\n\n\ngetAttributeValue  node=%s, attr=%s, val=%s\n\n\n", xmlNodeName, attributeName, attributeValue ); 
     return( attributeValue );
 }
 

function ProcessRivuletMsg(string smsg)
{   
    integer position; 
    integer responseid; 
    integer endpointid;
    string sessionid[50]; 
    //*DEBUG*/ print("\n\n\n\n\nProcessRivuletMsg: %s\n\n\n\n\n", smsg); 
    
    //Check to see if this is a login request and if so extract session id
    //This will only be called if we do not have a current session id.
    if ( len(gsRivuletSessionID) = 0 )
    {
        position = Find( "login-success", smsg, 1 );
        if ( position != 0 )
        {
            sessionid = getAttributeValue( "binding", "session-id", smsg );
            if ( len(sessionid) != 0 )
            {
                gsRivuletSessionID = sessionid;  
                print("RGM Login Successful\n");
                print("Session ID = %s\n", gsRivuletSessionID );
            }
        }
    }
    else
    {  
        //Get unused response structure from pool
        responseid = getUnusedResponse();
        
        if (responseid = 0) 
        {
            print("WARNING: No room for Rivulet Responses\n");
            return; 
        }
        //We now will take data from each XML response and put it on the receive
        //list for pickup by the connection list procsess thread. 
        ResponseList[responseid].COORELATIONID = getAttributeValue( "correlation","id", smsg ); 
        ResponseList[responseid].API_CMD_RESP = getAttributeValue( "api-cmd-rsp", "rsp", smsg ); 
        ResponseList[responseid].SERVICEID = getAttributeValue( "api-cmd-rsp", "service-id", smsg );
        ResponseList[responseid].API_CMD_ERROR = getAttributeValue( "api-fault", "fault-detail", smsg );
        ResponseList[responseid].ENDPOINT_ALIAS = getAttributeValue("api-cmd-rsp", "ep-port-alias-name", smsg );
        ResponseList[responseid].ENDPOINT_STATUS = getAttributeValue("api-cmd-rsp", "ep-port-alias-status-code", smsg );
        
        //*DEBUG*/print( "\n\n\n RespID = %d COORID = %s\n", responseid, ResponseList[responseid].COORELATIONID );
        //*DEBUG*/print( "ServiceID = %s\n", ResponseList[responseid].SERVICEID);
        //*DEBUG*/print( "CMDRESP = %s\n", ResponseList[responseid].API_CMD_RESP );
        //*DEBUG*/print( "CMDERROR = %s\n", ResponseList[responseid].API_CMD_ERROR ); 
        print("\n******BEGIN RGM Response Data**********\n"); 
        print("Response ID = %i\n", responseid);
        print("Correlation ID = %s\n", ResponseList[responseid].COORELATIONID);
        print("api-cmd-rsp = %s\n", ResponseList[responseid].API_CMD_RESP);
        //print("api-cmd-error = %s\n", ResponseList[responseid].API_CMD_ERROR); 

        if (find(RIVULET_CONNECT_SERVICE_SUCCESS_MSG, ResponseList[responseid].API_CMD_RESP))
        {
            print("*** Rivulet Connect Success Msg: Service ID = %s***\n", ResponseList[responseid].SERVICEID); 
        }        
        else if (find(RIVULET_DISCONNECT_SERVICE_SUCCESS_MSG, ResponseList[responseid].API_CMD_RESP))
        {
            print("*** Rivulet Disconnect Success Msg***\n"); 
        }
        else if (find(RIVULET_CONNECT_SERVICE_FAILURE_MSG, ResponseList[responseid].API_CMD_RESP))
        {
            print("*** Rivulet Connect Failure Msg: %s***\n", ResponseList[responseid].API_CMD_ERROR); 
        }
        else if (find(RIVULET_DISCONNECT_SERVICE_FAILURE_MSG, ResponseList[responseid].API_CMD_RESP))
        {
            print("*** Rivulet Disconnect Failure Msg: %s***\n", ResponseList[responseid].API_CMD_ERROR); 
        }
        print("******END RGM Response Data**********\n\n"); 
        ResponseList[responseid].INUSE = TRUE;
    }
}  

/*******************************************************************
 Rivulet XML Send Functions
 *******************************************************************/  

  
 STRING_FUNCTION addXMLHeader( string xmlString )
 {   
     integer contentLength;
     contentLength = Len( xmlString ); 
     xmlString = "Content-Type : text/rivapi\n" +  "Content-Length : " + itoa(contentLength) + "\n\n" + xmlString;
     return(xmlString); 
 }
 
 function sendLoginRequest()
 {   
    string sXMLLogin[4096];  
	string coorid[20];  
 	coorid = getCoorID();
 	sXMLLogin =  "<?xml version=\x221.0\x22 encoding=\x22UTF-8\x22?><api-envelope><api-version version = \x2205.01.00.R002\x22 ></api-version> <correlation id = \x22"
	 + coorid + "\x22 > </correlation> <binding access-method = \x22trusted\x22 ></binding><api-cmd-req req = \x22login\x22 ></api-cmd-req> </api-envelope>"; 
    sXMLLogin = addXMLHeader( sXMLLogin );
    sendData( sXMLLogin ); 
 }   
 
/****************************************************
 This will send a connection request to the RCAS server
 for the number of connections as indicated by the dvicount
 field in the Connection structure.
 
 Note:  Port aliases are automatically generated as follows
 
 HVP Source or Destination:   RM + Room ID + PT + Port ID
 			Example:		  RM1PT2
 			
 VEC Destination:	          RM + The Source RM ID + PT + The Source Port ID + VPV
            Example:          RM1PT2VPV
            
 Keep in mind that when creating a VEC connection this
 is always a unidirectional flow.  VEC also requires
 the IP address of the PC running VEC in order to route
 the video to it.
 *****************************************************/
 
function SendConnectRequest( integer connectionid )
 {   
     string sXMLConnect[1024];  
	 string coorid[20]; 
     integer dvicount,i; 
     string srcPortAlias[20];
     string dstPortAlias[20];
 	 dvicount = ConnectionList[connectionid].DVICnt; 
 	  	 
     if ( ConnectionList[connectionid].TYPE = TYPE_HVPTOHVP  )
     {   
        for ( i = 1 to dvicount )
        {  
            srcPortAlias = "RM" + itoa(ConnectionList[connectionid].Room1) + "PT" + itoa(i);
            dstPortAlias = "RM" + itoa(ConnectionList[connectionid].Room2) + "PT" + itoa(i); 
            coorid = getCoorID(); 
            setConnectionCoorID( connectionid,i, coorid ); 
            
            //HALF-DUPLEX OPERATION
            //svc-bidir = true
            //If half duplex was desired, set the parameter above to false...
            //future improvement.
             
            sXMLConnect =  "<?xml version=\x221.0\x22 encoding=\x22UTF-8\x22?><api-envelope><api-version version = \x2205.01.00.R002\x22 > </api-version> " +
            "<correlation id = \x22" + coorid + "\x22 > </correlation> <binding session-id = \x22"+ gsRivuletSessionID + "\x22 > </binding> " +
            "<api-cmd-req req = \x22connect-service\x22 svc-type = \x22dynamic\x22 svc-bidir = \x22true\x22 source-alias = \x22" + 
            srcPortAlias + "\x22 destination-alias = \x22" + dstPortAlias + "\x22 >" +
            "<source-selectors ></source-selectors>" +
			"<destination-selectors ></destination-selectors>" +
			"</api-cmd-req></api-envelope>"; 
            
      	    sXMLConnect = addXMLHeader( sXMLConnect );
            sendData( sXMLConnect );  
        }
     }
     else if ( ConnectionList[connectionid].TYPE = TYPE_HVPTOVEC )
     {  
        //We always assume that for VEC connections that we use DVI src 1
        srcPortAlias = "RM" + itoa(ConnectionList[connectionid].Room1) + "PT" + itoa(1);
        dstPortAlias = "RM" + itoa(ConnectionList[connectionid].Room1) + "PT" + itoa(1) + "VPV";
        coorid = getCoorID();
        setConnectionCoorID( connectionid,1, coorid ); 
       	 
        sXMLConnect =  "<?xml version=\x221.0\x22 encoding=\x22UTF-8\x22?><api-envelope><api-version version = \x2205.01.00.R002\x22 > </api-version> " +
        "<correlation id = \x22" + coorid + "\x22 > </correlation> <binding session-id = \x22"+ gsRivuletSessionID + "\x22 > </binding> " +
        "<api-cmd-req req = \x22connect-service\x22 svc-type = \x22dynamic\x22 svc-bidir = \x22false\x22 source-alias = \x22" + 
        srcPortAlias + "\x22 destination-alias = \x22" + dstPortAlias + "\x22 >" +
        "<source-selectors ></source-selectors>" +
	    "<destination-selectors  IP_ADDRESS=\x22" + ConnectionList[connectionid].VEC_IP + "\x22 ></destination-selectors>" +
		"</api-cmd-req></api-envelope>"; 
		//*DEBUG*/print( "\n\n\n VEC CONNECT IP_ADDRESS=%s\n\n", ConnectionList[connectionid].VEC_IP );
        sXMLConnect = addXMLHeader( sXMLConnect );
        sendData( sXMLConnect ); 
     }
     else
     {
         print( "Unsupported Connection Type:  Type = %d\n", ConnectionList[connectionid].TYPE );
     }
 }
 
function SendDisconnectRequest( integer connectionid )
 {     
     string sXMLDisconnect[1024]; 
     string coorid[20]; 
     string serviceid[20]; 
     integer i,dvicount; 
     dvicount = ConnectionList[connectionid].DVICnt; 
      
     for ( i = 1 to dvicount )
     {
         coorid = getCoorID(); 
         serviceid = getConnectionServiceID( connectionid, i );
         setConnectionCoorID( connectionid,i, coorid ); 
         
            sXMLDisconnect =  "<?xml version=\x221.0\x22 encoding=\x22UTF-8\x22?><api-envelope><api-version version = \x2205.01.00.R002\x22 ></api-version> <correlation id = \x22"
	         + coorid + "\x22 > </correlation> <binding session-id = \x22"+ gsRivuletSessionID + "\x22 > </binding> <api-cmd-req req = \x22disconnect-service\x22 service-id = \x22" + serviceid + "\x22></api-cmd-req> </api-envelope>";
            sXMLDisconnect = addXMLHeader( sXMLDisconnect );
            sendData( sXMLDisconnect );  
     }
 }      
 
 
function sendPortStatusRequest( integer connectionid )
{     
    string sXMLPortStatus[1024]; 
    string coorid[20]; 
    string serviceid[20]; 
    string PortAlias[20];
    integer i; 

    if (Endpoints[connectionid].RivEndpointType <> ENDPOINT_HVP)    
        return;                                                 
   
    PortAlias = "RM" + itoa(connectionid) + "PT" + itoa(1);
    coorid = getCoorID(); 
         
    sXMLPortStatus = "<?xml version=\x221.0\x22 encoding=\x22UTF-8\x22?>"
                   + "<api-envelope>"
                   + "<api-version version = \x2205.01.00.R002\x22 >"
                   + "</api-version>"
                   + " <correlation id = \x22"
                   + coorid 
	               + "\x22 > </correlation>"
	               + " <binding session-id = \x22"
	               + gsRivuletSessionID 
	               + "\x22 > </binding>"
	               + " <api-cmd-req req = \x22get-ep-port-alias-status\x22"
	               + " ep-port-alias-name = \x22" 
	               + PortAlias 
	               + "\x22></api-cmd-req> </api-envelope>";
    sXMLPortStatus = addXMLHeader( sXMLPortStatus );
    sendData( sXMLPortStatus );  
}


/*******************************************************************************************
  Events
*******************************************************************************************/
// INFO Need to check into how this is structured... didn't think we needed a "debounce" on TCP/IP connections.

PUSH sigRivuletConnected
{   
    integer i,j, dviid, dvicount, rid, gotallresp;
    integer iTimer;
    
    string coorid[10];	 
	print("Connected to RCAS\n");  
	
	iTimer = 0;
	// We are now connected to the RCAS server.  We must send login request.  
	// Wait for a few
	delay(500);
    sendLoginRequest();  
    
    while (sigRivuletConnected)
    {   
        iTimer = iTimer + 1;
        for( i = 1 to MAX_ENDPOINTS )
        {
            if ((iTimer mod 300) = 0)
            {
                sendPortStatusRequest(i);
            } 
            
            
            if ( ConnectionList[i].CurRqst = RQST_CONNECT )
            { 
                SendConnectRequest( i );
                ConnectionList[i].CurRqst = RQST_IDLE;
                ConnectionList[i].CurStatus = RIVULET_CONNECTING;  
                aoEndpointStatus[i] = RIVULET_CONNECTING;
            }
            else if ( ConnectionList[i].CurRqst = RQST_DISCONNECT )
            {  
                SendDisconnectRequest( i );
                ConnectionList[i].CurRqst = RQST_IDLE;
                ConnectionList[i].CurStatus = RIVULET_DISCONNECTING;
                aoEndpointStatus[i] = RIVULET_DISCONNECTING;   
            }
            else if ( ConnectionList[i].CurStatus = RIVULET_CONNECTING )
            {
                /*DEBUG*/print( "IN CONNECTING\n");
                gotallresp = TRUE; 
                dvicount = ConnectionList[i].DVICnt;
                for ( j = 1 to dvicount )
                { 
                    /*DEBUG*/print( "CONNECTING dviid=%d\n", j );  
                    coorid = getConnectionCoorID( i, j );
                    if ( coorid != "" )
                    {
                        //Check to see if we have gotten a response yet.
                        //Note: We might want to put a timeout on waiting
                        //      for a response.  This should not be a 
                        //      problem because if there is no response
                        //      chances are we lost connection to RCAS 
                        //      server.
                        rid = getResponseByCoorID( coorid );
                        if ( rid != 0 )
                        {
                            //Got response from connect
                            //Clear coorelation ID
                            setConnectionCoorID( i, j, "" );
                            //Set Service ID
                            setConnectionServiceID( i, j, ResponseList[rid].SERVICEID ); 
                            /*DEBUG*/print( "\n\nCID=%d, RID=%d, DVIID=%d, CONNECTIONLIST SERVICEID1 = %s\n", i,rid,j,ConnectionList[i].ServiceID1 );
                            /*DEBUG*/print( "CONNECTIONLIST SERVICEID2 = %s\n", ConnectionList[i].ServiceID2 );
                            /*DEBUG*/print( "CONNECTIONLIST SERVICEID3 = %s\n", ConnectionList[i].ServiceID3 );
                            /*DEBUG*/print( "CONNECTIONLIST SERVICEID4 = %s\n", ConnectionList[i].ServiceID4 );
                            //Clear Response
                            clearResponse( rid );
                        }
                        else
                        { 
                            print("Waiting for connect reply, line %i\n", j);
                            gotallresp = FALSE;
                        }
                    }
                }
                if ( gotallresp = TRUE )
                {
                    // Set Connection to Connected 
                    /*DEBUG*/print( "\n\n\n ***************** CONNECTED *****************\n\n\n");
                    ConnectionList[i].CurStatus = RIVULET_CONNECTED;
                    aoEndpointStatus[i] = RIVULET_CONNECTED;
                }
            }
            else if ( ConnectionList[i].CurStatus = RIVULET_DISCONNECTING )
            {   
            	/*DEBUG*/print( "\n\n\n\IN DISCONNECTING\n\n\n\n\n");
                gotallresp = TRUE;
                dvicount = ConnectionList[i].DVICnt; 
                for ( j = 1 to dvicount )
                {   
                    coorid = getConnectionCoorID( i, j );
                    if ( coorid != "" )
                    {  
                        /*DEBUG*/print( "DISCONNECTING dviid=%d\n\n", j );
                        //Check to see if we have gotten a response yet.
                        rid = getResponseByCoorID( coorid );
                        if ( rid != 0 )
                        {
                            print("Disconnecting, found msg\n");
                            //Got response from disconnect
                            //Clear coorelation ID
                            //setConnectionCoorID( i, j, "" );
                            //Clear Response
                            //clearResponse( rid );
                        }
                        else
                        {
                            print("Waiting for disconnect reply, line %i\n", j);
                            gotallresp = FALSE;
                        }
                    } 
                } 
                if ( gotallresp = TRUE )
                {
                    for (j = 1 to dvicount)
                    {
                        coorid = getConnectionCoorID(i, j);
                        rid = getResponseByCoorID(coorid);
                        clearResponse(rid);
                    }   
                    ClearConnection(i);
                    // Set Connection idle for now.  
                    // Should be RIVULET_DISCONNECTED after improvements. 
                    ConnectionList[i].CurStatus = RIVULET_IDLE; 
                    aoEndpointStatus[i] = RIVULET_IDLE;

                }
            }            
            else if ( ConnectionList[i].CurStatus = RIVULET_CONNECTED )
            { 
                // We should add code here to check the status of the Rivulet
                // services associated with this connection. 
            }  
        }

        // Check for Port Status Replies 
        for (i = 1 to RESPONSE_LIST_MAX)
        {
            if (ResponseList[i].INUSE = TRUE)
            {
                if (find(RIVULET_GET_PORT_STATUS_MSG, ResponseList[i].API_CMD_RESP))
                {
                    print("*** Rivulet Endpoint Status: %s, %s***\n", ResponseList[i].ENDPOINT_ALIAS,
                                               ResponseList[i].ENDPOINT_STATUS);
                    clearResponse(i);
                }
            }
        } 

        //delay(100);   Original...
        delay(20);
    } 
}  

RELEASE sigRivuletConnected
{  
	integer i; 
    print("Disconnected from the RCAS\n");  
	// Reset coorelation ID and session ID
	giRivuletCoorID = 0;
	gsRivuletSessionID = "";  
	clearConnectionList();
	clearResponseList();
} 


PUSH sigStartupComplete
{
    integer i; 
    
    if (giRivuletConfigured)
        doRivLinkEnable = ON;
}  

 /****************************************************
 This event function processes the incoming messages
 from the Rivulet RCAS server.  
 *****************************************************/
 /////////////////////////////////////////////////////////////////////////////////////////////
 //Note:  This code does not take into account a situation where a second chunk
 //       contains first a ending envelope and then an beginning from next message. 
 //       (this should not happen as Crestron seems to only process single complete messages)
 /////////////////////////////////////////////////////////////////////////////////////////////
CHANGE RxRivulet
{   
    integer iLen, spos, epos;
	string sFmRivulet[255];
	string sReceiveReturn[1024];

	sFmRivulet = RxRivulet; 
	clearbuffer(RxRivulet);
    iLen = len(sFmRivulet);
    
    // Gather all data in message chunk.    
    while (iLen)
    {
	    sReceiveReturn = sReceiveReturn + sFmRivulet;    
	    sFmRivulet = RxRivulet;
	    clearbuffer(RxRivulet);
	    iLen = len(sFmRivulet);
	} 
    
    // Check if beginning envelope is in chunk
    spos = Find( "<api-envelope>", sReceiveReturn, 1 );
	
	if ( spos != 0 ) // We have chunk with beginning envelope
	{   
	    // Check if ending envelope is in chunk
	    epos = Find( "</api-envelope>", sReceiveReturn, 1 );
	    if ( epos != 0 )
	    {  
	        // Since both are in chunk, we have complete xml, process.
	        ProcessRivuletMsg(sReceiveReturn);
	        gsResponseMsg = "";
	    }
	    else
	    {  
	        //We only have beginning of envelope, set global response and continue.
	        gsResponseMsg = sReceiveReturn;
	    }
	}
	else  // We have chunk w/o beginning envelope
	{  
	    //check if ending envelope is in chunk
	    epos = Find( "</api-envelope>", sReceiveReturn, 1 );
	    if ( epos != 0 )
	    { 
	    	//We found ending envelope. Add to global response, send Process Message and 
	    	//reset global response to empty
	    	gsResponseMsg = gsResponseMsg + sReceiveReturn;
	        ProcessRivuletMsg(gsResponseMsg);
	        gsResponseMsg = ""; 
	    }
	    else
	    { 
	        //We have XML without beginning or end (must be the middle).  
	        //We must add to global response and continue.
	        gsResponseMsg = gsResponseMsg + sReceiveReturn;
	    }
	}
} 

// This event parses information passed from ConferenceHub.
// It is used for configuration. 

// INFO - I believe this is initial video setups... based on configuration data received..  
//        Should be able to be tremendously simplified for Rivulet needs...
CHANGE siRivuletConfig
{
	string sInfo[255];
	string sSplit[255];
	string token[20];
	integer index, id, i, j, k, start, count;
	
	sInfo = siRivuletConfig;
	
	token = Remove(":", sInfo);				// Obtain first word
	token = left(token, len(token) - 1);	// Remove ":"
	sSplit = Remove(":", sInfo);			// Extract Index
	index = atoi(left(sSplit, len(sSplit) - 1));	// Remove ":", make integer
		
   	// Process SVideo information	
	if (token = "rivulet")
	{ 
	    giRivuletConfigured = ON;
	    
		sSplit = Remove(":", sInfo);	// Extract input start
		Endpoints[index].RivAudioInCnt = atoi(left(sSplit, len(sSplit) - 1));

		sSplit = Remove(":", sInfo);	// Extract input count
		Endpoints[index].RivAudioOutCnt = atoi(left(sSplit, len(sSplit) - 1));

		sSplit = Remove(":", sInfo);	// Extract output start
		Endpoints[index].RivDVIInCnt = atoi(left(sSplit, len(sSplit) - 1));

		sSplit = Remove(":", sInfo);	// Extract output count
		Endpoints[index].RivDVIOutCnt = atoi(left(sSplit, len(sSplit) - 1));

		sSplit = Remove(":", sInfo);	// Extract output start
		Endpoints[index].RivSVideoInCnt = atoi(left(sSplit, len(sSplit) - 1));

		sSplit = Remove(":", sInfo);	// Extract output count
		Endpoints[index].RivSVideoOutCnt = atoi(left(sSplit, len(sSplit) - 1));

		print("\t\tRivulet Endpoint %d: %d %d %d %d %d %d\n", 
		    index,
			Endpoints[index].RivAudioInCnt,
			Endpoints[index].RivAudioOutCnt,
			Endpoints[index].RivDVIInCnt,
			Endpoints[index].RivDVIOutCnt,
			Endpoints[index].RivSVideoInCnt,
			Endpoints[index].RivSVideoOutCnt);

        Endpoints[index].RivEndpointType = ENDPOINT_HVP; // will become Type VEC if VEC IP Address config'd
	}	// End of Rivulet information

	else if (token = "RivVEC")
	{ 
		sSplit = Remove(":", sInfo);	// Extract input start
		Endpoints[index].RivVEC_IP = left(sSplit, len(sSplit) - 1);

	    Endpoints[index].RivEndpointType = ENDPOINT_VEC;  //HVP or VEC
    }
} 



// This event parses information passed from ConferenceHub.
// It is used to initiate routing. 
// INFO - Dynamic Connect/Disconnect information from the rest of our hub control...
CHANGE siVidRoute
{
	string sRoute[255];
	string sSplit[255];
	string token[20];
	integer isrc, idst, isrcoff, idstoff, ipriv;
	
	sRoute = siVidRoute;
	
	token = Remove(":", sRoute);			// Obtain first word
	token = left(token, len(token) - 1);	// Remove ":"

	if (token = "enable")	// Connect two rooms for conferencing
	{
		sSplit = Remove(":", sRoute);	// Extract src
		isrc = atoi(left(sSplit, len(sSplit) - 1)); 
	
		sSplit = Remove(":", sRoute);	// Extract dst
		idst = atoi(left(sSplit, len(sSplit) - 1));

		RoutingEnable(isrc, idst);		 
	}
	else if (token = "disable")	// Disconnect two rooms that were in a conference
	{
		sSplit = Remove(":", sRoute);	// Extract src
		isrc = atoi(left(sSplit, len(sSplit) - 1)); 

		sSplit = Remove(":", sRoute);	// Extract dst
		idst = atoi(left(sSplit, len(sSplit) - 1));

		RoutingDisable(isrc, idst);
	}
	else if (token = "mutelocal")
	{
		; // No video changes for this command
	}
}

// This is a one-time event automatically called at startup 
// INFO - in the world of Crestron, we do not normally let "main" be the active process,
//        And, in our case, we probably want the TCP/IP connection, once it is
//        established be the main controlling module.
function Main()
{
	integer i, j;

    giRivuletConfigured = OFF;
    gsRivuletSessionID = "";
    giRivuletCoorID = 0;
    gsResponseMsg = "";	
    
	// Initialize Endpoint array
	for (i = 1 to MAX_ENDPOINTS)
	{
		Endpoints[i].CustomEndpointID = 0; 
		Endpoints[i].FixedEndpointID = 0;
		
		Endpoints[i].RivAudioInCnt = 0;
		Endpoints[i].RivAudioOutCnt = 0;
		Endpoints[i].RivDVIInCnt = 0;
		Endpoints[i].RivDVIOutCnt = 0;
		Endpoints[i].RivSVideoInCnt = 0;
		Endpoints[i].RivSVideoOutCnt = 0;
		
		Endpoints[i].RivEndpointType = 0;
		Endpoints[i].RivVEC_IP = "";
		
		Endpoints[i].Privacy = 0;
	}	

    for (i = 1 to MAX_FIXED_ENDPOINTS)
    {
    	for (j = 1 to MAX_FIXED_SOURCES)
			FixedRoutingTable[i].Source[j] = 0;

    	for (j = 1 to MAX_FIXED_TARGETS)
			FixedRoutingTable[i].Target[j] = 0;
    }  
    
    clearConnectionList();
    clearResponseList();  

    // Enable I/O   
    WaitForInitializationComplete();

}
