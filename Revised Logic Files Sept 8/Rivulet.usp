/*********************************************************************************
  Compiler Directives
  (Uncomment and declare compiler directives as needed)
*********************************************************************************/
// #SYMBOL_NAME ""
// #HINT ""
// #DEFINE_CONSTANT


#DEFINE_CONSTANT MAX_ID_LENGTH         30
#DEFINE_CONSTANT MAX_RIVULET_EPTS      48 


//CurRqst values
#DEFINE_CONSTANT RQST_IDLE              0
#DEFINE_CONSTANT RQST_CONNECT           1
#DEFINE_CONSTANT RQST_DISCONNECT        2

#DEFINE_CONSTANT CMIS_NORIVULET         0
#DEFINE_CONSTANT CMIS_YESRIVULET        1  

#DEFINE_CONSTANT RIVULET_EP_OFFLINE     0
#DEFINE_CONSTANT RIVULET_EP_AVAILABLE   1
#DEFINE_CONSTANT RIVULET_EP_NOTAVAIL    2  

//CMIS CurStatus values
// Found in CMIS_Hub_Library

//Rivulet CurStatus values
// Found in CMIS_Hub_Library

//gsRivuletTimer
#DEFINE_CONSTANT RIVULET_TIMEOUT      100     //20 seconds for connect/disconnect - delay(20) is 200ms, 5*20 = 100
#DEFINE_CONSTANT CMIS_TIMEOUT         150     //30 seconds for connect/disconnect - 200ms, 5*30 = 150

//Connection Type  
#DEFINE_CONSTANT CALL_NONE              0
#DEFINE_CONSTANT CALL_HVPTOHVP          1
#DEFINE_CONSTANT CALL_HVPTOVEC          2 
#DEFINE_CONSTANT CALL_DVPTODVP          3
#DEFINE_CONSTANT CALL_XVPTOXVP          4

//Endpoint Type
#DEFINE_CONSTANT ENDPOINT_NOT_CONFIGURED    0
#DEFINE_CONSTANT ENDPOINT_VEC_IN            1
#DEFINE_CONSTANT ENDPOINT_HVP_IN            2
#DEFINE_CONSTANT ENDPOINT_HVP_OUT           3
#DEFINE_CONSTANT ENDPOINT_HVP_BI            4
#DEFINE_CONSTANT ENDPOINT_DVP_IN		    5
#DEFINE_CONSTANT ENDPOINT_DVP_OUT           6
#DEFINE_CONSTANT ENDPOINT_DVP_BI            7

//XML Receive
#DEFINE_CONSTANT MAX_RESPONSES             20  

#DEFINE_CONSTANT RIVULET_LOGIN_SUCCESS_MSG              "login-success" 
#DEFINE_CONSTANT RIVULET_GET_PORT_STATUS_MSG            "get-ep-port-alias-status" 
#DEFINE_CONSTANT RIVULET_GET_SERVICE_STATUS_MSG         "get-service-status"
#DEFINE_CONSTANT RIVULET_CONNECT_SERVICE_FAILURE_MSG    "connect-service-failure"  
#DEFINE_CONSTANT RIVULET_CONNECT_SERVICE_SUCCESS_MSG    "connect-service-success"
#DEFINE_CONSTANT RIVULET_DISCONNECT_SERVICE_FAILURE_MSG "disconnect-service-failure"
#DEFINE_CONSTANT RIVULET_DISCONNECT_SERVICE_SUCCESS_MSG "disconnect-service-success"
//BOOLEAN
#DEFINE_CONSTANT TRUE	1
#DEFINE_CONSTANT FALSE  0

#DEFINE_CONSTANT MAX_RIVULET_BUFFER 	2176

/*********************************************************************************
  Include Libraries
  (Uncomment and include additional librarys as needed)
*********************************************************************************/
// #CRESTRON_LIBRARY ""

#USER_LIBRARY "CMIS_Hub_Library"

/*******************************************************************************************
  DIGITAL, ANALOG and SERIAL INPUTS and OUTPUTS
  (Uncomment and declare inputs and outputs as needed)
*******************************************************************************************/

// Inputs
// DIGITAL_INPUT 

DIGITAL_INPUT   sigStartupComplete;  //Startup completed event
DIGITAL_INPUT	sigRivuletConnected; //Rivulet TCP/IP connection is live event.
DIGITAL_INPUT   diDebug;             //debug input, activated via console command.

// ANALOG_INPUT  
ANALOG_INPUT    aiRivLinkStatus;     //Rivulet TCP/IP connection status 

// STRING_INPUT	
BUFFER_INPUT 	RxRivulet[MAX_RIVULET_BUFFER];      //Rivulet Rx Data stream
STRING_INPUT	siRivConfig[255];    //Rivulet Configuration data 
STRING_INPUT	siVidRoute[255];     //CMIS call connection data.

// Outputs
// DIGITAL_OUTPUT 
DIGITAL_OUTPUT  doRivLinkEnable;     //Rivulet TCP/IP enable, set high after startup

// ANALOG_OUTPUT 

// STRING_OUTPUT
STRING_OUTPUT	TxRivulet;           //Rivulet Tx Data stream

ANALOG_OUTPUT   aocmis_epstatus[MAX_ENDPOINTS]; //CMIS endpoint status.  Indicates status of an endpoint in a call.
ANALOG_OUTPUT   aorivulet_epstatus[MAX_ENDPOINTS];  // For right now, will only support endpoint status
                                                       // for 2 rivulet endpoints per CMIS endpoint 
/*******************************************************************************************
  Structure Definitions
  (Uncomment and define structure definitions as needed)
  Note:  Be sure to initialize all declared STRING variables as needed
         For example, in Function Main: struct.myString = "";
*******************************************************************************************/

STRUCTURE CMIS_ENDPOINT
{
    INTEGER CurRqst;
    INTEGER CurStatus;
    INTEGER CallActive;
    INTEGER LineCnt;  
    INTEGER CfgType;
    INTEGER Rivulet_epid[4];
}; 

STRUCTURE RIVULET_ENDPOINT
{
    STRING  epname[MAX_ID_LENGTH];
    INTEGER eptype;       
    INTEGER cmis_epid;
    INTEGER cmis_line;
    INTEGER CurStatus;
    INTEGER CallActive;
	STRING  VEC_IP[MAX_ID_LENGTH];      //If VEC, this is the IP Address	
};

STRUCTURE RIVULET_CONNECTION
{
    INTEGER endpoint1;    //Multiple Rivulet Connections may support a CMIS Call.
    INTEGER endpoint2; 
    integer CallType;
    INTEGER CurRqst;      // 
    INTEGER CurStatus;    //
    INTEGER CurTimer; 
    INTEGER cmis_cid;
    STRING  ErrorString[200];
    STRING  CorrelationID[MAX_ID_LENGTH];
    STRING  ServiceID[MAX_ID_LENGTH]; 
    STRING  ServiceCode[MAX_ID_LENGTH]; 
}; 
 
STRUCTURE CMIS_CONNECTION
{
    INTEGER Room1;    //Endpoint 1
    INTEGER Room2;    //Endpoint 2
    INTEGER CurRqst;      //Connection
    INTEGER CurStatus;    //Rivulet p, RIVUL
    INTEGER CurTimer;  
    INTEGER rivulet_cid[4];  
    INTEGER rivulet_status[4];
    STRING  ErrorString[200];
}; 

STRUCTURE ResponseData
{
    STRING COORELATIONID[MAX_ID_LENGTH];
    STRING SERVICEID[MAX_ID_LENGTH];   
    STRING SERVICECODE[MAX_ID_LENGTH];
    STRING API_CMD_RESP[50];
    STRING API_CMD_ERROR[100];
    STRING ENDPOINT_ALIAS[MAX_ID_LENGTH]; 
    STRING ENDPOINT_STATUS[MAX_ID_LENGTH];
    INTEGER INUSE;
};

//endpoint management and call management
CMIS_ENDPOINT         cmis_eptlist[MAX_ENDPOINTS]; 
CMIS_CONNECTION       cmis_callist[MAX_ENDPOINTS];

RIVULET_ENDPOINT      rivulet_eptlist[MAX_ENDPOINTS];
RIVULET_CONNECTION    rivulet_callist[MAX_ENDPOINTS]; 

// Receive msg list 
ResponseData ResponseList[MAX_RESPONSES];



/*******************************************************************************************
  Global Variables
*******************************************************************************************/

STRING  gsRivuletSessionID[50];
STrING  gsFmRivulet[MAX_RIVULET_BUFFER]; 
STRING  gsResponseMsg[MAX_RIVULET_BUFFER];   
STRING  gsReceiveReturn[MAX_RIVULET_BUFFER];

INTEGER giRivuletFlag;
INTEGER giRivuletDisconnectFlag;
INTEGER giRivuletConfigured;     

// Rivulet Communication Variables
INTEGER giRivuletCoorID;       
INTEGER giRivuletCount;
INTEGER gsRivuletTimer;
INTEGER giRxSemaphore;

INTEGER giBufferStartPos;	// Remember start position of <api-envelope>
		
/*******************************************************************************************
  Functions
*******************************************************************************************/

function Printful(string sMessage)
{
	string sprintString[256];
	string sremainString[MAX_RIVULET_BUFFER];
    integer iLen;
    
    sremainString = sMessage;
    
    iLen = len(sremainString);
	while (iLen > 0)
	{
		if (iLen > 255)
		{
			sprintString = left(sremainString,255);
			sremainString = right(sremainString,iLen-255);
		}
		else
		{
			sprintString = sremainString;
			sremainString = "";
		}
		iLen = len(sremainString);
		print("%s\n", sprintString);
	}
}


// For Debugging
// This function takes the nonprintable characters in a string and prints them as HEX
// Note: BYTE is the Creston version of ASC
String_function sPrintable(string sMessage)
{
	string outstring[MAX_RIVULET_BUFFER];
	string scharacter[1];
	string hexstr[4];
	integer i;
	integer prthex;

	outstring = "";

	for (i = 1 to len(sMessage))
	{
		prthex = OFF;
		scharacter = mid(sMessage, i, 1);

		if (byte(sMessage, i) < 31)
			prthex = ON;
		else if (byte(sMessage, i) > 126)
			prthex = ON;

		if (prthex) 
		{
			makestring(hexstr, "\\x%02X", byte(sMessage, i));
			outstring = outstring + hexstr;
		}
		else
			outstring = outstring + scharacter;
	}

	return(outstring);
}  

integer_function SetNibble( integer status, integer nibble, integer data)
{
    integer shiftcnt;
    integer shiftposition;
    integer shiftvalue; 
    integer output;

    shiftcnt = 4 * (nibble-1);   // determine how many bits to shift
    shiftposition = (15 << shiftcnt);  // mark correct nibble.

    shiftvalue = data << shiftcnt;  // set data into correct nibble. 
    
    output = status;
        
    output = output & (NOT(shiftposition)); 
    output = output | shiftvalue;   
    
    return (output);
} 


function clear_rivulet_eptlist()
{
    integer i;
    
    for (i=1 to MAX_ENDPOINTS)
    {
        rivulet_eptlist[i].epname     = "";
        rivulet_eptlist[i].eptype     = ENDPOINT_NOT_CONFIGURED;
        rivulet_eptlist[i].cmis_epid  = 0;  
        rivulet_eptlist[i].cmis_line  = 0;
        rivulet_eptlist[i].CurStatus  = RIVULET_EP_OFFLINE;
        rivulet_eptlist[i].CallActive = OFF; 
        rivulet_eptlist[i].VEC_IP     = ""; 
    }
} 
      
function clear_cmis_eptlist()
{
    integer i, j;
    
    for (i=1 to MAX_ENDPOINTS)
    {
        cmis_eptlist[i].CurRqst     = RQST_IDLE;
        cmis_eptlist[i].CurStatus   = CMIS_IDLE;
        cmis_eptlist[i].CallActive  = OFF;
        cmis_eptlist[i].LineCnt     = 0; 
        cmis_eptlist[i].CfgType     = CMIS_NORIVULET;
        
        for (j=1 to 4)
            cmis_eptlist[i].Rivulet_epid[j] = 0; 
    }
}  

function set_rivulet_status(integer i, integer status)
{
    integer riv_ept1, riv_ept2; 
    integer cmis_ept1, cmis_ept2;
    integer line;  

    rivulet_callist[i].CurStatus = status;                    

    riv_ept1 = rivulet_callist[i].endpoint1;
    riv_ept2 = rivulet_callist[i].endpoint2;

    if ((riv_ept1 = 0) || (riv_ept2 = 0))
        return;
        
    cmis_ept1  = rivulet_eptlist[riv_ept1].cmis_epid;
    cmis_ept2  = rivulet_eptlist[riv_ept2].cmis_epid;  
    line       = rivulet_eptlist[riv_ept1].cmis_line;  // same line number for each endpoint.   
                                                  
    print("Setting Rivulet Status, line #%i, between endpoints %i and %i\n",
                                                     line, cmis_ept1, cmis_ept2);  

    aorivulet_epstatus[cmis_ept1] = SetNibble(aorivulet_epstatus[cmis_ept1], line, status);        
    aorivulet_epstatus[cmis_ept2] = SetNibble(aorivulet_epstatus[cmis_ept2], line, status);       
   
}


function clear_rivulet_connection(integer i)
{
    integer ept1, ept2; 

    print( "RIVULET: Clearing Rivulet connection, Line %i\n", i);  
    print( "RIVULET: Rivulet serviceid=%s DISCONNECTED\n", rivulet_callist[i].ServiceID);  
    
    ept1 = rivulet_callist[i].endpoint1;
    ept2 = rivulet_callist[i].endpoint2; 
       
    if (ept1 > 0)
        rivulet_eptlist[ept1].CallActive = OFF; 
        
    if (ept2 > 0)
        rivulet_eptlist[ept2].CallActive = OFF;    
         
    rivulet_callist[i].endpoint1     = 0;
    rivulet_callist[i].endpoint2     = 0;
    rivulet_callist[i].calltype      = CALL_NONE;
    rivulet_callist[i].CurRqst       = RQST_IDLE;  
    //rivulet_callist[i].CurStatus     = RIVULET_IDLE;
    rivulet_callist[i].cmis_cid      = 0;
    rivulet_callist[i].ErrorString   = "";
    rivulet_callist[i].CorrelationID = "";
    rivulet_callist[i].ServiceID     = ""; 
    rivulet_callist[i].ServiceCode   = "";  
    
    set_rivulet_status(i, RIVULET_IDLE);
}


function set_rivulet_connection(integer i, string id)
{
    integer ept1, ept2;
    integer line, cmis_ept1, cmis_ept2;
    string  serviceid[MAX_ID_LENGTH];

    print( "RIV: Rivulet service CONNECTED\n");  
    
    serviceid = id;

    ept1   = rivulet_callist[i].endpoint1;
    ept2   = rivulet_callist[i].endpoint2;

    rivulet_eptlist[ept1].CallActive = ON;
    rivulet_eptlist[ept2].CallActive = ON;
    
    rivulet_callist[i].ServiceID     = serviceid; 
    rivulet_callist[i].CorrelationID = "";

    set_rivulet_status(i, RIVULET_CONNECTED);         

}



function clear_cmis_connection(integer i)
{
    integer j, rivid;
    
    cmis_callist[i].Room1       = 0;    //Endpoint 1
    cmis_callist[i].Room2       = 0;    //Endpoint 2
    cmis_callist[i].CurRqst     = RQST_IDLE;      //Connection
    cmis_callist[i].CurStatus   = CMIS_IDLE;
    cmis_callist[i].ErrorString = "";
    
    for (j=1 to 4)
    {
        rivid = cmis_callist[i].rivulet_cid[j];
        
        if (rivid > 0)
            clear_rivulet_connection(rivid);
            
        cmis_callist[i].rivulet_cid[j]    = 0;
        cmis_callist[i].rivulet_status[j] = RIVULET_IDLE;
    }
}

function clear_rivulet_callist()
{
    integer i;
    
    for (i=1 to MAX_ENDPOINTS)
        clear_rivulet_connection(i);
}   

function clear_cmis_callist()
{
    integer i;
    
    for (i=1 to MAX_ENDPOINTS)
        clear_cmis_connection(i);
}

function clearResponse( integer i )
{
    ResponseList[i].COORELATIONID = "";
    ResponseList[i].SERVICEID = "";
    ResponseList[i].SERVICECODE = "";
    ResponseList[i].API_CMD_RESP = "";
    ResponseList[i].API_CMD_ERROR = "";
    ResponseList[i].ENDPOINT_ALIAS = "";
    ResponseList[i].ENDPOINT_STATUS = "";
    ResponseList[i].INUSE = FALSE;
} 

function clearResponseList()
{ 
    integer i;
    for ( i = 1 to MAX_RESPONSES )
    {
        ClearResponse(i);
    }
} 

// SUPPORTING FUNCTION CALLS FOR RIVULET

STRING_FUNCTION getCoorID()
{
    if ( giRivuletCoorid = 65535 )
    {
        giRivuletCoorid = 1;
    } 
    else
    {
        giRivuletCoorid = giRivuletCoorid + 1; 
    }
    return( itoa( giRivuletCoorid ));  
}                                      


STRING_FUNCTION addXMLHeader( string xmlString )
{   
     integer contentLength;
     contentLength = Len( xmlString ); 
     xmlString = "Content-Type : text/rivapi\n" +  "Content-Length : " + itoa(contentLength) + "\n\n" + xmlString;
     return(xmlString); 
}   

function sendData( string xmlData )
{ 
    // Can only send 255 bytes at a time 
    integer length; 
    string sendString[160];
    string tmpString[MAX_RIVULET_BUFFER];
    tmpString = xmlData;
    while(1)	
	{
	    length = len(tmpString);
	    if (length > 160)
	    {
	        sendString = RemoveByLength(160, tmpString);
	        TxRivulet = sendString; 
            //* DEBUG */ print( "Sending To Rivulet:  %s len=%d\n", sendString, len(sendString) ); 
            processlogic();            
	    }
	    else
	    {
	        sendstring = tmpstring;
	        TxRivulet = sendString; 
	        //* DEBUG */ print( "Sending Last To Rivulet:  %s\n", sendString );
	        break;
	    }   
	}
}  

STRING_FUNCTION getAttributeValue( string xmlNodeName, string attributeName, string xml )
 {  
     string tmpstring[MAX_RIVULET_BUFFER], tmpnodename[255], rmtmpstring[MAX_RIVULET_BUFFER], attributeValue[255];
     integer position,svalpos,evalpos,attrvallen;
     tmpstring = xml;

     //find the node name... if it is present
     tmpnodename = "<" + xmlNodeName;
     position = Find( tmpnodename, tmpstring, 1 );
     // If node is not found get out
     if ( position = 0 ) return( "" );
     position = position + len(tmpnodename);
     rmtmpstring = RemoveByLength( position, tmpstring);
     position = Find( attributeName, tmpstring, 1 ); 
     // Really need to extract ONLY the XML node and then 
     // search. 
     if ( position = 0 ) return ( "" );
     position = Find( "\x22", tmpstring, position );
     svalpos = position;
     position = Find( "\x22", tmpstring, position+1);
     evalpos = position;
     //* DEBUG */ print( "getAttributeValue  svalpos=%d, evalpos=%d, tmpstring=%s\n", svalpos, evalpos, tmpstring);
     attrvallen = evalpos - svalpos - 1; 
     attributeValue = Mid(tmpstring, svalpos+1, attrvallen );
     //* DEBUG */ print( "\n\n\ngetAttributeValue  node=%s, attr=%s, val=%s\n\n\n", xmlNodeName, attributeName, attributeValue ); 
     return( attributeValue );
 } 
 
INTEGER_FUNCTION getUnusedResponse()
{ 
    integer cnt, i; 
    
    for ( i = 1 to MAX_RESPONSES )
    {
        if ( ResponseList[i].INUSE = FALSE )
        {
            return( i );
        }
    }
    return( 0 );
}



function ProcessRivuletMsg()
{   
    integer position; 
    integer responseid; 
    integer endpointid;
    string sessionid[50]; 
    string smsg[MAX_RIVULET_BUFFER];
    string sprintmsg[MAX_RIVULET_BUFFER];
    
    smsg = gsReceiveReturn;    
    //*DEBUG*/ MakeString(sprintmsg, "\nProcessRivuletMsg: [[%s]]\n", sPrintable(smsg));
    //*DEBUG*/ printful(sprintmsg); 
    
    //Check to see if this is a login request and if so extract session id
    //This will only be called if we do not have a current session id.
    if ( len(gsRivuletSessionID) = 0 )
    {
        position = Find( "login-success", smsg, 1 );
        if ( position != 0 )
        {
            sessionid = getAttributeValue( "binding", "session-id", smsg );
            if ( len(sessionid) != 0 )
            {
                gsRivuletSessionID = sessionid;  
                print("RIV: RGM Login Successful\n");
                print("Session ID = %s\n", gsRivuletSessionID );
            }
        }
    }
    else
    {  
        //Get unused response structure from pool
        responseid = getUnusedResponse();
        
        if (responseid = 0) 
        {
            print("WARNING: No room for Rivulet Responses\n");
            return; 
        }
        //We now will take data from each XML response and put it on the receive
        //list for pickup by the connection list procsess thread. 
        ResponseList[responseid].COORELATIONID   = getAttributeValue("correlation","id", smsg ); 
        ResponseList[responseid].API_CMD_RESP    = getAttributeValue("api-cmd-rsp", "rsp", smsg ); 
        ResponseList[responseid].SERVICEID       = getAttributeValue("api-cmd-rsp", "service-id", smsg ); 
        ResponseList[responseid].SERVICECODE     = getAttributeValue("api-cmd-rsp", "service-status-code", smsg);
        ResponseList[responseid].API_CMD_ERROR   = getAttributeValue("api-fault", "fault-detail", smsg );
        ResponseList[responseid].ENDPOINT_ALIAS  = getAttributeValue("api-cmd-rsp", "ep-port-alias-name", smsg );
        ResponseList[responseid].ENDPOINT_STATUS = getAttributeValue("api-cmd-rsp", "ep-port-alias-status-code", smsg );

        //*DEBUG*/print( "\n\n\n RespID = %d COORID = %s\n", responseid, ResponseList[responseid].COORELATIONID );
        //*DEBUG*/print( "ServiceID = %s\n", ResponseList[responseid].SERVICEID);
        //*DEBUG*/print( "CMDRESP = %s\n", ResponseList[responseid].API_CMD_RESP );
        //*DEBUG*/print( "CMDERROR = %s\n", ResponseList[responseid].API_CMD_ERROR ); 
        if (diDebug)
        {
            print("\n******BEGIN RGM Response Data**********\n"); 
            print("Response ID = %i\n", responseid);
            print("Correlation ID = %s\n", ResponseList[responseid].COORELATIONID);
            print("api-cmd-rsp = %s\n", ResponseList[responseid].API_CMD_RESP);
            print("api-ep-port-alias-name = %s\n", ResponseList[responseid].ENDPOINT_ALIAS);
            print("api-cmd-error = %s\n", ResponseList[responseid].API_CMD_ERROR); 
            print("api-ep-port-alias-status-code = %s\n", ResponseList[responseid].ENDPOINT_STATUS);
        }
        // perform "DIS" connect checks first, because "CONNECT" msgs are subset of "DISCONNECT" msgs.
        if (find(RIVULET_DISCONNECT_SERVICE_SUCCESS_MSG, ResponseList[responseid].API_CMD_RESP))
        {
            print("*** Rivulet Disconnect Success Msg***\n"); 
        }
        else if (find(RIVULET_DISCONNECT_SERVICE_FAILURE_MSG, ResponseList[responseid].API_CMD_RESP))
        {
            print("*** Rivulet Disconnect Failure Msg: %s***\n", ResponseList[responseid].API_CMD_ERROR); 
        }
        else if (find(RIVULET_CONNECT_SERVICE_SUCCESS_MSG, ResponseList[responseid].API_CMD_RESP))
        {
            print("*** Rivulet Connect Success Msg: Service ID = %s***\n", ResponseList[responseid].SERVICEID); 
        }        
        else if (find(RIVULET_CONNECT_SERVICE_FAILURE_MSG, ResponseList[responseid].API_CMD_RESP))
        {
            print("*** Rivulet Connect Failure Msg: %s***\n", ResponseList[responseid].API_CMD_ERROR); 
        }
        if (diDebug) print("******END RGM Response Data**********\n\n"); 
        ResponseList[responseid].INUSE = TRUE;
    }
}  

// JRJ 090728 - split this code out of RxRivulet and added while loop to ensure multiple msgs 
// can be processed on single CHANGE event if needed
function ProcessReceivedMessages()
{
	integer spos, epos;

	spos = 1;
	epos = 1;
	
	while ((spos) && (epos))
	{
	    spos = Find( "<api-envelope>", gsResponseMsg, 1 );

	    if ( spos != 0 ) // We have chunk with beginning envelope
	    {   
	    	/*DEBUG*/print ("DEBUG: Found <api-envelope> at %d\n", spos);

	        // Check if ending envelope is in chunk 
	        epos = Find( "</api-envelope>", gsResponseMsg, spos+14);	// 14 = len(<api-envelope)
	        if ( epos != 0 )
	        {
         	    /*DEBUG*/print ("DEBUG: Found </api-envelope> at %d\n", epos);	          
	            // Since both are in chunk, we have complete xml, process.
	            print("DEBUG: Length of buffer string is %i\n", len(gsResponseMsg));
	            gsReceiveReturn = removebylength(epos+14, gsResponseMsg);	// 14 = len(</api-envelope)-1
	            print("DEBUG: Length of string removed is %i\n", len(gsReceiveReturn)); 
	            print("DEBUG: Length of string remaining is %i\n", len(gsResponseMsg));
	            ProcessRivuletMsg();
	            gsReceiveReturn = ""; 
	        } 
	    }
	    if (spos > epos)
	        print ("RIVULET MESSAGE PROCESSING ERROR, ERROR, ERROR....spos=%i, epos=%i\n", spos, epos);  
	    if (spos > 200)
	        print ("MAJOR MAJOR RIVULET MESSAGE ERROR --- SPOS > 200\n");
	}

}

//**********************************************************************************************
// BEGIN RIVULET TRANSACTIONS
//**********************************************************************************************

function SendLoginRequest()
{   
    string sXMLLogin[4096];  
	string coorid[MAX_ID_LENGTH];  
 	coorid = getCoorID();
 	sXMLLogin =  "<?xml version=\x221.0\x22 encoding=\x22UTF-8\x22?><api-envelope><api-version version = \x2205.01.00.R002\x22 ></api-version> <correlation id = \x22"
	 + coorid + "\x22 > </correlation> <binding access-method = \x22trusted\x22 ></binding><api-cmd-req req = \x22login\x22 ></api-cmd-req> </api-envelope>"; 
    sXMLLogin = addXMLHeader( sXMLLogin );
    sendData( sXMLLogin ); 
} 

function sendPortStatusRequest( integer index )
{     
    string sXMLPortStatus[MAX_RIVULET_BUFFER]; 
    string coorid[MAX_ID_LENGTH]; 
    string serviceid[MAX_ID_LENGTH]; 
    string PortAlias[MAX_ID_LENGTH];
    integer i; 

	// Don't issue port status request if session id is empty
	if (len(gsRivuletSessionID) = 0)
	{
		if (diDebug) print ("RIV: Skip Port Status Request: Session ID empty\n");
		return;
	}
	
    if (rivulet_eptlist[index].eptype = ENDPOINT_NOT_CONFIGURED)
        return;
        
    if (rivulet_eptlist[index].eptype = ENDPOINT_VEC_IN)    
        return;                                                 

    // Don't query endpoints if a call is active... service query will cover.
    if (rivulet_eptlist[index].CallActive = ON)
        return;

    PortAlias = rivulet_eptlist[index].epname;

    if (diDebug) print("RIV: Send Port Status Request, %s\n", PortAlias);           
    coorid = getCoorID(); 
         
    sXMLPortStatus = "<?xml version=\x221.0\x22 encoding=\x22UTF-8\x22?>"
                   + "<api-envelope>"
                   + "<api-version version = \x2205.01.00.R002\x22 >"
                   + "</api-version>"
                   + " <correlation id = \x22"
                   + coorid 
	               + "\x22 > </correlation>"
	               + " <binding session-id = \x22"
	               + gsRivuletSessionID 
	               + "\x22 > </binding>"
	               + " <api-cmd-req req = \x22get-ep-port-alias-status\x22"  
	               + " ep-port-alias-name = \x22" 
	               + PortAlias 
	               + "\x22></api-cmd-req> </api-envelope>";
    sXMLPortStatus = addXMLHeader( sXMLPortStatus );
    sendData( sXMLPortStatus ); 
}  


function sendServiceStatusRequest( integer index )
{     
    string sXMLPortStatus[MAX_RIVULET_BUFFER]; 
    string coorid[MAX_ID_LENGTH]; 
    string serviceid[MAX_ID_LENGTH]; 
    string PortAlias[MAX_ID_LENGTH];
    integer i; 

	// Don't issue service status request if session id is empty
	if (len(gsRivuletSessionID) = 0)
	{
		if (diDebug) print ("RIV: Skip Service Status Request: Session ID empty\n");
		return;
	}
			
    serviceid = rivulet_callist[index].ServiceID;   
    
    if (serviceid = "")         // don't send a service id message if the service has been lost.
        return;
    coorid    = getCoorID(); 

    if (diDebug) print("RIV: Send Service Status Request, %s\n", serviceid);           
             
    sXMLPortStatus = "<?xml version=\x221.0\x22 encoding=\x22UTF-8\x22?>"
                   + "<api-envelope>"
                   + "<api-version version = \x2205.01.00.R002\x22 >"
                   + "</api-version>"
                   + " <correlation id = \x22"
                   + coorid 
	               + "\x22 > </correlation>"
	               + " <binding session-id = \x22"
	               + gsRivuletSessionID 
	               + "\x22 > </binding>"
	               + " <api-cmd-req req = \x22get-service-status\x22"  	               
	               + " service-id = \x22" 
	               + serviceid 
	               + "\x22></api-cmd-req> </api-envelope>";
    sXMLPortStatus = addXMLHeader( sXMLPortStatus );
    sendData( sXMLPortStatus ); 
}       


function SendConnectRequest( integer cid )
 {   
     string sXMLConnect[MAX_RIVULET_BUFFER];  
	 string coorid[MAX_ID_LENGTH]; 
     integer ep1, ep2; 
     string srcPortAlias[MAX_ID_LENGTH];
     string dstPortAlias[MAX_ID_LENGTH]; 
     string vec_ip[MAX_ID_LENGTH];

     ep1 = rivulet_callist[cid].endpoint1;
     ep2 = rivulet_callist[cid].endpoint2;

     srcPortAlias = rivulet_eptlist[ep1].epname;
     dstPortAlias = rivulet_eptlist[ep2].epname;

     coorid = getCoorID(); 
     rivulet_callist[cid].CorrelationID = coorid; 
 	  	 
     if ( rivulet_callist[cid].CallType = CALL_HVPTOHVP  )
     {            
        //HALF-DUPLEX OPERATION
        //svc-bidir = true
        //If half duplex was desired, set the parameter above to false...
        //future improvement.
             
        sXMLConnect =  "<?xml version=\x221.0\x22 encoding=\x22UTF-8\x22?><api-envelope><api-version version = \x2205.01.00.R002\x22 > </api-version> " +
            "<correlation id = \x22" + coorid + "\x22 > </correlation> <binding session-id = \x22"+ gsRivuletSessionID + "\x22 > </binding> " +
            "<api-cmd-req req = \x22connect-service\x22 svc-type = \x22dynamic\x22 svc-bidir = \x22true\x22 source-alias = \x22" + 
            srcPortAlias + "\x22 destination-alias = \x22" + dstPortAlias + "\x22 >" +
            "<source-selectors ></source-selectors>" +
			"<destination-selectors ></destination-selectors>" +
			"</api-cmd-req></api-envelope>"; 
            
     	sXMLConnect = addXMLHeader( sXMLConnect );
        sendData( sXMLConnect );  
    }
    else if ( rivulet_callist[cid].CallType = CALL_HVPTOVEC )
    {  

       //srcPortAlias = "RM" + itoa(ConnectionList[cid].Room1) + "PT" + itoa(1);
       //dstPortAlias = "RM" + itoa(ConnectionList[cid].Room1) + "PT" + itoa(1) + "VPV";
        if (rivulet_eptlist[ep1].eptype = ENDPOINT_VEC_IN)
            vec_ip = rivulet_eptlist[ep1].VEC_IP;
        else if (rivulet_eptlist[ep2].eptype = ENDPOINT_VEC_IN)
            vec_ip = rivulet_eptlist[ep2].VEC_IP;
        else
            vec_ip = "";
       	 
        sXMLConnect =  "<?xml version=\x221.0\x22 encoding=\x22UTF-8\x22?><api-envelope><api-version version = \x2205.01.00.R002\x22 > </api-version> " +
            "<correlation id = \x22" + coorid + "\x22 > </correlation> <binding session-id = \x22"+ gsRivuletSessionID + "\x22 > </binding> " +
            "<api-cmd-req req = \x22connect-service\x22 svc-type = \x22dynamic\x22 svc-bidir = \x22false\x22 source-alias = \x22" + 
            srcPortAlias + "\x22 destination-alias = \x22" + dstPortAlias + "\x22 >" +
            "<source-selectors ></source-selectors>" +
	        "<destination-selectors  IP_ADDRESS=\x22" + vec_ip + "\x22 ></destination-selectors>" +
		    "</api-cmd-req></api-envelope>"; 
		    
		//*DEBUG*/print( "\n\n\n VEC CONNECT IP_ADDRESS=%s\n\n", ConnectionList[cid].VEC_IP );
        sXMLConnect = addXMLHeader( sXMLConnect );
        sendData( sXMLConnect ); 
    }
    else if ( rivulet_callist[cid].CallType = CALL_DVPTODVP )
    {
        // identical to HVPTOHVP...
        //FULL-DUPLEX OPERATION
        //svc-bidir = false
        //If full duplex was desired, set the parameter above to true...
        //future improvement.
             
        sXMLConnect =  "<?xml version=\x221.0\x22 encoding=\x22UTF-8\x22?><api-envelope><api-version version = \x2205.01.00.R002\x22 > </api-version> " +
            "<correlation id = \x22" + coorid + "\x22 > </correlation> <binding session-id = \x22"+ gsRivuletSessionID + "\x22 > </binding> " +
            "<api-cmd-req req = \x22connect-service\x22 svc-type = \x22dynamic\x22 svc-bidir = \x22false\x22 source-alias = \x22" + 
            srcPortAlias + "\x22 destination-alias = \x22" + dstPortAlias + "\x22 >" +
            "<source-selectors ></source-selectors>" +
			"<destination-selectors ></destination-selectors>" +
			"</api-cmd-req></api-envelope>"; 
            
     	sXMLConnect = addXMLHeader( sXMLConnect );
        sendData( sXMLConnect );     
    }
    else
    {
        print( "Unsupported Connection Type:  Type = %d\n", rivulet_callist[cid].CallType );
    } 
    
}


function SendDisconnectRequest( integer cid )
{     
    string sXMLDisconnect[MAX_RIVULET_BUFFER]; 
    string coorid[MAX_ID_LENGTH]; 
    string serviceid[MAX_ID_LENGTH]; 
    integer i;  
      
    coorid = getCoorID(); 
    rivulet_callist[cid].CorrelationID = coorid;
         
    serviceid = rivulet_callist[cid].ServiceID; 

    //*DEBUG*/print( "Disconnecting Line=%i, Service id=%s\n", i, serviceid );
         
    sXMLDisconnect = "<?xml version=\x221.0\x22 encoding=\x22UTF-8\x22?>"
                   + "<api-envelope>"
                   + "<api-version version = \x2205.01.00.R002\x22 ></api-version>"
                   + " <correlation id = \x22"
	               + coorid
	               + "\x22 > </correlation>"
	               + " <binding session-id = \x22"
	               + gsRivuletSessionID 
	               + "\x22 > </binding>"
	               + " <api-cmd-req req = \x22disconnect-service\x22 service-id = \x22" 
	               + serviceid
	               + "\x22></api-cmd-req> </api-envelope>";
    sXMLDisconnect = addXMLHeader( sXMLDisconnect );
    sendData( sXMLDisconnect ); 
    
}      
 

  
//**********************************************************************************************
// END RIVULET TRANSACTIONS
//**********************************************************************************************

integer_function GetAvailableRivulet()
{
    integer i, availconnection;

    availconnection = 0;
    
    for (i=1 to MAX_ENDPOINTS)
    {
//        if (rivulet_callist[i].CurStatus = RIVULET_IDLE) JRJ 090728 - must also check CurRqst
        if ((rivulet_callist[i].CurStatus = RIVULET_IDLE) && (rivulet_callist[i].CurRqst = RQST_IDLE))
        {
            availconnection = i;
            break;
        }
    }
    
    return(availconnection);
}   


integer_function GetAvailableCMIS()
{
    integer i, availconnection;

    availconnection = 0;
    
    for (i=1 to MAX_ENDPOINTS)
    {
        if (cmis_callist[i].CurStatus = CMIS_IDLE) 
        {
            availconnection = i;
            break;
        }
    }
    return(availconnection);
}  

integer_function find_cmis_connection(integer ept1, integer ept2)
{
    integer i, cmis_connection;
    
    cmis_connection = 0;
           
    for (i=1 to MAX_ENDPOINTS)
    {
        //if (cmis_callist[i].CurStatus <> RIVULET_IDLE)
        //{
            if ((cmis_callist[i].Room1 = ept1) || (cmis_callist[i].Room2 = ept1))
            {
                cmis_connection = i;
                break;
            }
        //}
    }   
    return(cmis_connection);
}

function RoutingEnable(integer endpoint1, integer endpoint2)
{
    integer i,j;
    integer rivep1, rivep2;
    integer cmis_connection;
    integer rivulet_connection; 
    

    // Don't activate the connection unless both endpoints are rivulet capable.
    if ((cmis_eptlist[endpoint1].CfgType = CMIS_NORIVULET) || (cmis_eptlist[endpoint2].CfgType = CMIS_NORIVULET)) 
    {
        print("RIV: Both endpoints must be rivulet, ept1=%i, ept2=%i\n", endpoint1, endpoint2); 
        return;
    }
        
    cmis_connection = GetAvailableCMIS();
    
    if (cmis_connection = 0)
    {
        print("RIV: No Available CMIS connections\n");
        return;                            
    } 

    print("RIV: CMIS Call - Request Connect, callid=%i, ept1=%i, ept2=%i\n", cmis_connection, endpoint1, endpoint2); 
       
    cmis_callist[cmis_connection].Room1 = endpoint1;
    cmis_callist[cmis_connection].Room2 = endpoint2;

    for (j=1 to 4)
    {
        rivep1 = cmis_eptlist[endpoint1].Rivulet_epid[j];
        rivep2 = cmis_eptlist[endpoint2].Rivulet_epid[j];
        
        if ((rivep1 = 0) || (rivep2 = 0))
            break;
        
        rivulet_connection = GetAvailableRivulet();
    
        if (rivulet_connection = 0)
        {
            print("RIV: No more Available Rivulet connections\n");
            break;                            
        } 
        else
        {
            print("RIV: Setting up Rivulet %i\n", j);
        }
        
        if ((rivulet_eptlist[rivep1].eptype = ENDPOINT_HVP_BI) && (rivulet_eptlist[rivep2].eptype = ENDPOINT_HVP_BI))
        {
            if (diDebug) print("HVP to HVP\n");
            rivulet_callist[rivulet_connection].endpoint1 = rivep1;
            rivulet_callist[rivulet_connection].endpoint2 = rivep2;
            rivulet_callist[rivulet_connection].CallType  = CALL_HVPTOHVP;                       
        }

        else if ((rivulet_eptlist[rivep1].eptype = ENDPOINT_VEC_IN) && (rivulet_eptlist[rivep2].eptype = ENDPOINT_HVP_BI))
        {
            if (diDebug) print("VEC to HVP\n");
            rivulet_callist[rivulet_connection].endpoint1 = rivep2;
            rivulet_callist[rivulet_connection].endpoint2 = rivep1;
            rivulet_callist[rivulet_connection].CallType  = CALL_HVPTOVEC;
        }
    
        else if ((rivulet_eptlist[rivep1].eptype = ENDPOINT_HVP_BI) && (rivulet_eptlist[rivep2].eptype = ENDPOINT_VEC_IN))
        {
            if (diDebug) print("HVP to VEC\n");
            rivulet_callist[rivulet_connection].endpoint1 = rivep1;
            rivulet_callist[rivulet_connection].endpoint2 = rivep2;
            rivulet_callist[rivulet_connection].CallType  = CALL_HVPTOVEC;
        }
        else if ((rivulet_eptlist[rivep1].eptype = ENDPOINT_DVP_BI) && (rivulet_eptlist[rivep2].eptype = ENDPOINT_DVP_BI))
        {
            if (diDebug) print("DVP to DVP, Bidir\n");
            rivulet_callist[rivulet_connection].endpoint1 = rivep1;
            rivulet_callist[rivulet_connection].endpoint2 = rivep2;
            rivulet_callist[rivulet_connection].CallType  = CALL_DVPTODVP;
        } 
        else if ((rivulet_eptlist[rivep1].eptype = ENDPOINT_DVP_IN) && (rivulet_eptlist[rivep2].eptype = ENDPOINT_DVP_OUT))
        {
            if (diDebug) print("DVP to DVP, EP2 Out\n");
            rivulet_callist[rivulet_connection].endpoint1 = rivep2;
            rivulet_callist[rivulet_connection].endpoint2 = rivep1;
            rivulet_callist[rivulet_connection].CallType  = CALL_DVPTODVP;
        }
        else if ((rivulet_eptlist[rivep1].eptype = ENDPOINT_DVP_OUT) && (rivulet_eptlist[rivep2].eptype = ENDPOINT_DVP_IN))
        {
            if (diDebug) print("DVP to DVP, EP1 Out\n");
            rivulet_callist[rivulet_connection].endpoint1 = rivep1;
            rivulet_callist[rivulet_connection].endpoint2 = rivep2;
            rivulet_callist[rivulet_connection].CallType  = CALL_DVPTODVP;
        }                
        else
        {
            print("Not a valid endpoint combination\n");
            return;
        } 
    
        print("RIV: Rqst Rivulet Connect %s to %s submitted\n", rivulet_eptlist[rivep1].epname, 
                                                                rivulet_eptlist[rivep2].epname);            

        cmis_callist[cmis_connection].rivulet_cid[j] = rivulet_connection; 

        // rivulet_callist[rivulet_connection].CurStatus = RIVULET_IDLE;  JRJ 090728 - does nothing, rivulet_connection is only set to items already RIVULET_IDLE
        rivulet_callist[rivulet_connection].CurRqst   = RQST_CONNECT; 
        rivulet_callist[rivulet_connection].cmis_cid  = cmis_connection;
    }
    
    cmis_callist[cmis_connection].CurRqst = RQST_CONNECT;
} 


function RoutingDisable(integer endpoint1, integer endpoint2)
{
    integer i,j;
    integer cmis_connection, rivulet_connection;
    string ept1[MAX_ID_LENGTH], ept2[MAX_ID_LENGTH];

    // Don't deactivate the connection unless both endpoints are rivulet capable.
    if ((cmis_eptlist[endpoint1].CfgType = CMIS_NORIVULET) || (cmis_eptlist[endpoint2].CfgType = CMIS_NORIVULET)) 
    {
        print("RIV: Both endpoints must be rivulet\n");
        return;
    }

    cmis_connection = find_cmis_connection(endpoint1, endpoint2);
            
    if (cmis_connection = 0)
    {
        print("Connection not found for endpoints %d, %d\n", endpoint1, endpoint2);
        return;
    }

    print("RIV: CMIS Call - Request Disconnect, ept1=%i, ept2=%i\n", endpoint1, endpoint2); 

    for (j=1 to 4)
    {
        rivulet_connection = cmis_callist[cmis_connection].rivulet_cid[j];
        
        if (rivulet_connection)
        {
            ept1 = rivulet_eptlist[rivulet_callist[rivulet_connection].endpoint1].epname;
            ept2 = rivulet_eptlist[rivulet_callist[rivulet_connection].endpoint2].epname;
            print("RIV: disconnect rivulet %s to %s\n", ept1, ept2);
           
            set_rivulet_status(rivulet_connection, RIVULET_IDLE);
            rivulet_callist[rivulet_connection].CurRqst   = RQST_DISCONNECT; 
   }
    }
            
    cmis_callist[cmis_connection].CurRqst = RQST_DISCONNECT;            
} 

INTEGER_FUNCTION getResponseByCoorID( string coorid )
{
    integer i;
    for ( i = 1 to MAX_RESPONSES )
    {
        if ( find (coorid, ResponseList[i].COORELATIONID ))
        {
            if (ResponseList[i].INUSE = TRUE) // don't let it be used if the msg has not yet been flagged "in use"
                return( i );
        }
    }
    return( 0 );
}



integer_function check_cmis_connection(integer i)
{
    integer j, cid, status; 
    integer connect_cnt, disconnect_cnt, line_cnt, error_cnt, call_cnt; 
    integer replyrcvd;
    
    line_cnt       = 0;
    connect_cnt    = 0;
    disconnect_cnt = 0;  
    error_cnt      = 0; 
    call_cnt       = 0;
            
    for (j=1 to 4)
    {
        cid = cmis_callist[i].rivulet_cid[j];
                
        if (cid)
        {   
            line_cnt = line_cnt + 1;

            status = rivulet_callist[cid].CurStatus;  
                        
            if (status = RIVULET_CONNECTED)
                connect_cnt = connect_cnt + 1;  
            else if (status = RIVULET_DISCONNECTED)
                disconnect_cnt = disconnect_cnt + 1; 
            else if ((status = RIVULET_CONNECT_ERROR) || (status = RIVULET_DISCONNECT_ERROR))
                error_cnt = error_cnt + 1;   
            else if (status = RIVULET_CALL_ERROR)
                call_cnt = call_cnt + 1;
        }
    }
    
    if (line_cnt = connect_cnt) 
    {
        return(CMIS_CONNECTED);
    }
    else if (line_cnt = disconnect_cnt)
    {
        if (didebug) print("+++++++++ RIVULET:  check_cmis_connections() declaring call DISCONNECTED\n");
        return(CMIS_DISCONNECTED); 
    }
    else if (call_cnt > 0)
    {
        if (didebug) print("+++++++++ RIVULET:  check_cmis_connections() declaring call CALL CONNECTION LOST\n");
        return(CMIS_ERROR);
    }
    else if ((line_cnt = error_cnt) || (line_cnt = (error_cnt + disconnect_cnt)) || (line_cnt = (error_cnt + connect_cnt)))
    { 
        // conditions to watch for are:
        //    total errors equal to total lines
        //    disconnected lines + errored lines equal to total lines
        //    connected lines + errored lines equal to total lines
        //print("+++++++++ RIVULET:  check_cmis_connections() declaring call CONNECT OR DISCONNECT ERROR\n");
        return (CMIS_ERROR);
    }
    else
    {
        //print("+++++++++ RIVULET:  check_cmis_connections() declaring call IN BETWEEN\n");
        return(CMIS_INBETWEEN);              
    }
}  

integer_function SendRivuletMessages(integer i)
{
    integer iMsgSentFlag;

	iMsgSentFlag = OFF;
    if (rivulet_callist[i].CurRqst = RQST_CONNECT )
    { 
        print("RIV: Rivulet Connection Rqst - RQST_CONNECT\n");
        SendConnectRequest( i );
        iMsgSentFlag = ON;
        rivulet_callist[i].CurRqst   = RIVULET_IDLE; 
        rivulet_callist[i].CurTImer  = RIVULET_TIMEOUT; 
        set_rivulet_status(i, RIVULET_CONNECTING);        
    }
    
    else if ( rivulet_callist[i].CurRqst = RQST_DISCONNECT )
    {
        print("RIV: Rivulet Connection Rqst - RQST_DISCONNECT, Line %i\n", i);
          
        if (rivulet_callist[i].ServiceID <> "")
        {
            print("Sending Rivulet DISCONNECT, Line %i\n", i);
            SendDisconnectRequest( i );
            iMsgSentFlag = ON;        
            rivulet_callist[i].CurRqst   = RIVULET_IDLE; 
            rivulet_callist[i].CurTImer  = RIVULET_TIMEOUT;                
            set_rivulet_status(i, RIVULET_DISCONNECTING); 
        }
        else                                                                         
        {
            print("Don't send Rivulet DISCONNECT, Line %i\n", i);
            // Don't send Disconnect, since no service ID and no service connected...       
            rivulet_callist[i].CurRqst     = RIVULET_IDLE;
            //rivulet_callist[i].CurTImer  = RIVULET_TIMEOUT; 
            set_rivulet_status(i, RIVULET_DISCONNECTED);
        }
    } 
    
    return(iMsgSentFlag);
}


function ProcessRivuletConnections(integer i)
{
    integer rid;
	
    if (rivulet_callist[i].CurTimer)
        rivulet_callist[i].CurTimer = rivulet_callist[i].CurTimer - 1;

    //status = rivulet_callist[i].CurStatus;
   
    if (rivulet_callist[i].CurStatus = RIVULET_IDLE)
        return;

    else if (rivulet_callist[i].CurStatus = RIVULET_CONNECTED)
        return;

    // process the terminations first, because they will only be active for one cycle. 
    // this applies to DISCONNECT, DISCONNECT_ERROR, and CONNECT_ERROR       
    else if (rivulet_callist[i].CurStatus = RIVULET_DISCONNECTED ) 
        return;

    else if (rivulet_callist[i].CurStatus = RIVULET_DISCONNECT_ERROR)
        return;

    else if ( rivulet_callist[i].CurStatus = RIVULET_CONNECTING )
    {
        if (didebug) print( "RIV: Rivulet Connection Status - RIVULET_CONNECTING\n");
        if (rivulet_callist[i].CurTimer = 0)
        {
             // Timer expire, go to error state.
             set_rivulet_status(i, RIVULET_CONNECT_ERROR);  // Previously was TIMEOUT_ERROR
        }
        else
        {        
            // Check to see if the reply has been rcv'd 
            rid = getResponseByCoorID(rivulet_callist[i].CorrelationID);

            if (rid !=0)
            {
                print("\n\nRIV: Connecting, ResponseID=%i, CorrelationID=%s, API_CMD_RESP=%s\n",
                                       rid, ResponseList[rid].CoorelationID, ResponseList[rid].API_CMD_RESP);                        
                print("RIV: Connecting, CorrelationID=%s\n", rivulet_callist[i].CorrelationID); 
                                       
                print("found reply...coorid=%s\n", ResponseList[rid].COORELATIONID);
                if (find("failure", ResponseList[rid].API_CMD_RESP))
                {
                    set_rivulet_status(i, RIVULET_CONNECT_ERROR);        
                }
                else
                {
                    set_rivulet_connection(i, ResponseList[rid].SERVICEID);
                }
                clearResponse(rid); 
            }
        }
    }  
                        
    else if (rivulet_callist[i].CurStatus = RIVULET_DISCONNECTING )
    {
        /*DEBUG*/print( "RIV: Rivulet Connection Status - RIVULET_DISCONNECTING\n");  
        if (rivulet_callist[i].CurTimer = 0)
        {
             // Timer expire, go to error state.
             set_rivulet_status(i, RIVULET_DISCONNECT_ERROR);  // Previously was TIMEOUT_ERROR
        }
        else
        {        
            // Check to see if the reply has been rcv'd 
            rid = getResponseByCoorID(rivulet_callist[i].CorrelationID);

            if (rid !=0)
            {
                print("\n\nRIV: Disconnecting ResponseID=%i, CorrelationID=%s, API_CMD_RESP=%s\n", 
                                           rid, ResponseList[rid].CoorelationID, ResponseList[rid].API_CMD_RESP);                        
                print("RIV: Disconnecting, CorrelationID=%s\n", rivulet_callist[i].CorrelationID);                        
                if (find("failure", ResponseList[rid].API_CMD_RESP)) 
                {
                    set_rivulet_status(i, RIVULET_DISCONNECT_ERROR);        
                }
                else
                {
                    set_rivulet_status(i, RIVULET_DISCONNECTED);   
                }     
                clearResponse(rid); 
            } 
        }
    }
}   

   
function Process_cmis_connection(integer i)
{
    integer status;
     
    if (cmis_callist[i].CurTimer)
        cmis_callist[i].CurTimer = cmis_callist[i].CurTimer - 1;
   
    // Processing Connect or Disconnect requests
    if (cmis_callist[i].CurRqst = RQST_CONNECT )
    { 
        print("RIV: Processing CMIS Connection Rqst - RQST_CONNECT\n");
        cmis_callist[i].CurStatus = CMIS_CONNECTING;   
                
        // Rivulet call connects have already been submitted.
        cmis_callist[i].CurRqst  = CMIS_IDLE; 
        cmis_callist[i].CurTImer = CMIS_TIMEOUT;
                
        aocmis_epstatus[cmis_callist[i].Room1] = CMIS_CONNECTING; 
        aocmis_epStatus[cmis_callist[i].Room2] = CMIS_CONNECTING; 
    }
    
    else if ( cmis_callist[i].CurRqst = RQST_DISCONNECT )
    {
        print("RIV: Processing CMIS Connection Rqst - RQST_DISCONNECT\n");
        cmis_callist[i].CurStatus = CMIS_DISCONNECTING; 
                
        // Rivulet call disconnects have already been submitted.
        cmis_callist[i].CurRqst  = CMIS_IDLE; 
        cmis_callist[i].CurTImer = CMIS_TIMEOUT;
 
        aocmis_epStatus[cmis_callist[i].Room1] = CMIS_DISCONNECTING; 
        aocmis_epStatus[cmis_callist[i].Room2] = CMIS_DISCONNECTING; 
    }

    // Now process current status...    
    // Process the CMIS_ERROR condition first, so that on the very next cycle, it can revert to
    // CMIS_IDLE.  Intent:  CMIS_ERROR stays active for one cycle only.

    status = check_cmis_connection(i); 
    
    if (cmis_callist[i].CurStatus = CMIS_IDLE)
        return;

    else if ( cmis_callist[i].CurStatus = CMIS_ERROR )
    {
        cmis_callist[i].CurStatus = CMIS_IDLE;
        aocmis_epStatus[cmis_callist[i].Room1] = CMIS_IDLE; 
        aocmis_epStatus[cmis_callist[i].Room2] = CMIS_IDLE; 
    }

    else if (cmis_callist[i].CurStatus = CMIS_CONNECTED)
    {
        if (status = CMIS_ERROR)
        {
             print("RIV: Current Call Connected:  CMIS error state\n");
             cmis_callist[i].CurStatus = CMIS_ERROR;
             aocmis_epStatus[cmis_callist[i].Room1] = CMIS_ERROR; 
             aocmis_epStatus[cmis_callist[i].Room2] = CMIS_ERROR; 
        }
    }
        
    else if ( cmis_callist[i].CurStatus = CMIS_CONNECTING )
    {
        print("RIV: CMIS Connection Status - CMIS_CONNECTING\n");
        if (status = CMIS_CONNECTED)
        {
             print("RIV: CMIS CONNECTED\n");
             cmis_callist[i].CurStatus = CMIS_CONNECTED;
             aocmis_epStatus[cmis_callist[i].Room1] = CMIS_CONNECTED; 
             aocmis_epStatus[cmis_callist[i].Room2] = CMIS_CONNECTED; 
        } 
        else if (status = CMIS_ERROR)
        {
             print("RIV: Current Call Connecting:  CMIS error state\n");
             cmis_callist[i].CurStatus = CMIS_ERROR;
             aocmis_epStatus[cmis_callist[i].Room1] = CMIS_ERROR; 
             aocmis_epStatus[cmis_callist[i].Room2] = CMIS_ERROR; 
             //clear_cmis_connection(i);
        }
        else if (cmis_callist[i].CurTimer = 0)
        {
             // Timer expire, go to error state.
             cmis_callist[i].CurStatus = CMIS_ERROR;                    
             aocmis_epStatus[cmis_callist[i].Room1] = CMIS_ERROR; 
             aocmis_epStatus[cmis_callist[i].Room2] = CMIS_ERROR; 
        }
    }
    
    else if ( cmis_callist[i].CurStatus = CMIS_DISCONNECTING )
    {
        /*DEBUG*/print( "RIVULET: CMIS DISCONNECTING\n");                 
        if (status = CMIS_DISCONNECTED)
        {
             print("RIVULET: CMIS DISCONNECTED\n");
             cmis_callist[i].CurStatus = CMIS_DISCONNECTED;
             aocmis_epStatus[cmis_callist[i].Room1] = CMIS_DISCONNECTED; 
             aocmis_epStatus[cmis_callist[i].Room2] = CMIS_DISCONNECTED; 
        }
        else if (status = CMIS_ERROR)
        {
             print("RIV: Current Call Disconnecting:  CMIS error state\n");
             cmis_callist[i].CurStatus = CMIS_ERROR;
             aocmis_epStatus[cmis_callist[i].Room1] = CMIS_ERROR; 
             aocmis_epStatus[cmis_callist[i].Room2] = CMIS_ERROR; 
        }
        else if (cmis_callist[i].CurTimer = 0)
        {
             // Timer expire, go to disconnect state.
             cmis_callist[i].CurStatus = CMIS_ERROR;                    
             aocmis_epStatus[cmis_callist[i].Room1] = CMIS_ERROR; 
             aocmis_epStatus[cmis_callist[i].Room2] = CMIS_ERROR; 
        } 
    }
    
    else if ( cmis_callist[i].CurStatus = CMIS_DISCONNECTED )
    { 
        cmis_callist[i].CurStatus = CMIS_IDLE;                                                        
        aocmis_epStatus[cmis_callist[i].Room1] = CMIS_IDLE; 
        aocmis_epStatus[cmis_callist[i].Room2] = CMIS_IDLE; 
        clear_cmis_connection(i);
    }
}   

function ProcessRivuletEndpointStatus(integer index)
{
    integer i, endpoint;
    string sname[MAX_ID_LENGTH];
    string status[MAX_ID_LENGTH];

    endpoint = 0;

    sname = ResponseList[index].ENDPOINT_ALIAS;

    if (find("failure", ResponseList[index].API_CMD_RESP))
    {
        print ("Port Status Query failure: %s\n", sname); 
        return;
    }
    
    print("*** Rivulet Endpoint: %s, %s***\n", sname,
                                               ResponseList[index].ENDPOINT_STATUS);

    for (i=1 to MAX_ENDPOINTS)
    {
        if (find(rivulet_eptlist[i].epname, sname))
            endpoint = i;
        else
            break;
    }
    
    if (endpoint)    
        if (find("NOT_AVAILABLE", ResponseList[index].ENDPOINT_STATUS)) 
            // have a reply WITHOUT "NOT_AVAILABLE", then endpoint is useable.
            if (rivulet_eptlist[endpoint].CallActive) 
            {     
                rivulet_eptlist[endpoint].CurStatus = RIVULET_EP_NOTAVAIL;
                status = "CALL ACTIVE";
            }
            else 
            {
                rivulet_eptlist[endpoint].CurStatus = RIVULET_EP_OFFLINE;                    
                status = "ENDPOINT OFFLINE"; 
            }
        else 
        {
            rivulet_eptlist[endpoint].CurStatus = RIVULET_EP_AVAILABLE;
            status = "AVAILABLE"; 
        }
    else
        return;
                               
} 


function ProcessRivuletServiceStatus(integer i)
{
    integer j, line;
    integer cmis_ept1, cmis_ept2;  
    integer riv_ept1, riv_ept2;  
    integer callid;  
    integer rivid;
 
    string id[MAX_ID_LENGTH];
    string code[MAX_ID_LENGTH]; 
    
    id    = ResponseList[i].SERVICEID;
    code  = ResponseList[i].SERVICECODE;
    rivid = 0; 
            
    print("*** Rivulet Connection: Service ID=%s, Status=%s ***\n", id, code);
                           
    for (j=1 to MAX_ENDPOINTS)
    {
        if (find(id, rivulet_callist[j].SERVICEID))
        {
            rivulet_callist[j].SERVICECODE = code; 
            rivid = j;
            break;
        }
    }            

    if ((rivid > 0) && find("LOST", code))
    { 
        print("Looking at rivulet_callist entry %i\n", rivid);
        //callid   = rivulet_callist[rivid].cmis_cid; 
        riv_ept1 = rivulet_callist[rivid].endpoint1;
        riv_ept2 = rivulet_callist[rivid].endpoint2;
        
        //print("Rivulet Service Failure, ServiceID=%s, cmis callid=%i\n", id, callid);  
        //cmis_ept1   = cmis_callist[callid].Room1;
        //cmis_ept2   = cmis_callist[callid].Room2;  

        cmis_ept1   = rivulet_eptlist[riv_ept1].cmis_epid;
        cmis_ept2   = rivulet_eptlist[riv_ept2].cmis_epid;  
        line        = rivulet_eptlist[riv_ept1].cmis_line;  // same line number for each endpoint.                                                 
        print("Rivulet Service Failure, ServiceID=%s, cmis line #%i, between endpoints %i and %i\n",
                                                     id, line, cmis_ept1, cmis_ept2);  

        //aocmis_epstatus[cmis_ept1] = CMIS_ERROR;      // should not process here...
        //aocmis_epstatus[cmis_ept2] = CMIS_ERROR; 
 
        if (didebug) print("Rivulet Service Lost between Rooms %i and %i\n", cmis_ept1, cmis_ept2); 
        if (didebug) print("Rivulet Endpoints %i and %i\n", riv_ept1, riv_ept2);     

        rivulet_callist[rivid].ServiceID = "";    // Clear the service ID, because it isn't valid.      
        set_rivulet_status(rivid, RIVULET_CALL_ERROR);   
        //clear_rivulet_connection(rivid);

    }

}


PUSH sigRivuletConnected
{   
    integer i,j, dviid, linecount, rid, gotallresp;
    integer iTimer, iDelay, iCmdSent;
    
    string coorid[10];	 
	print("Connected to RCAS\n");     

	// We are now connected to the RCAS server.  We must send login request.  
	// Wait for a few
	delay(500);
    sendLoginRequest();  
    delay(250); // Wait ~2.5 seconds before sending any status messages

    iTimer = 0;	
    iDelay = 0;

    while (sigRivuletConnected)
    { 
		// Timer is used to limit when commands are sent.
        iTimer = iTimer + 1; 
        
        if (iDelay)
        	iDelay = iDelay - 1;

        if (iTimer > 300)	// Force timer back to 0 after 300 (300 * 200ms = 1 minute)       	
            iTimer = 0;

		ProcessReceivedMessages();	// Always process received messages, and don't send anything else until we have processed them all

/*		Status requests are causing flooding problems.  They are not necessary so disable for now.
        // Check Rivulet endpoints 
        for( i = 1 to MAX_ENDPOINTS )
        {
            // Send Rivulet Port query. 
            if ((iTimer mod (300 + ( 10 * i ))) = 0)	// Send on iTimer evenly divisible by 310, 320, 330 ... 540.
            {
                sendPortStatusRequest(i);  // does not send a query unless configured and not actively in a call
            }
        }
 */ 
 
         // Don't need to worry about checking CMIS endpoints... Conference Hub will handle
        // Check CMIS connections                     
        for( i = 1 to MAX_ENDPOINTS )
            Process_cmis_connection(i);
 
        // Check for connect/disconnect of Rivulet connections
        for( i = 1 to MAX_ENDPOINTS )
        { 
            if (!iDelay)
            {
	            iCmdSent = SendRivuletMessages(i);
	            
	            if (iCmdSent)
	            {
		            iDelay = 5; // Wait 5 * 0.2s before processing another connect or disconnect command
		            break;
	            }		
            }
            ProcessRivuletConnections(i);
        }

        // Check on status of active Rivulet connections
        for( i = 1 to MAX_ENDPOINTS )
        {
            if ( rivulet_callist[i].CurStatus = RIVULET_CONNECTED )            
               if ((10*i) = iTimer) // Send on iTimer = 2, 4, 6, 8 seconds... 
            { 
                    sendServiceStatusRequest(i);
            }
        }
        

        // Check for Query Replies 
        for (i = 1 to MAX_RESPONSES)
        {
            if (ResponseList[i].INUSE = TRUE)
            {
                if (find(RIVULET_GET_PORT_STATUS_MSG, ResponseList[i].API_CMD_RESP))
                {
                    ProcessRivuletEndpointStatus(i);
                    clearResponse(i);
                } 
                else if (find(RIVULET_GET_SERVICE_STATUS_MSG, ResponseList[i].API_CMD_RESP))
                {
                    ProcessRivuletServiceStatus(i);
                    clearResponse(i);                     
                }
                else
                {
                   print("Old Message?: CorrelationID=%s, %s\n",ResponseList[i].COORELATIONID, ResponseList[i].API_CMD_RESP);
// JRJ 090728 - if old message isn't blown away unconditionally, will encounter this condition infinitely
//                   if (len(ResponseList[i].API_CMD_RESP) = 0) 
//                   {
                       print("Blew away message\n");
                       clearResponse(i);  
//                   }
                }
            }
        } 
 
        //delay(100);   //Original...
        delay(20);
        
        if (giRivuletDisconnectFlag = ON)
        	break;                    // let new instance of event restart everything...   
        
    } 

    giRivuletDisconnectFlag = OFF;   // clear it for next time...
    
}  

RELEASE sigRivuletConnected
{  
	integer i; 
    print("Disconnected from the RCAS\n");  
    
    giRivuletDisconnectFlag = ON;
    
	// Reset coorelation ID and session ID
	giRivuletCoorID = 0;
	gsRivuletSessionID = "";  
	clearResponseList();

    // It should not be necessary to clear endpoint lists because
    // they do not change if the rivulet RGM restarts.
    clear_rivulet_callist();     
    clear_cmis_callist();
} 


/*******************************************************************************************
  Events
*******************************************************************************************/
// INFO Need to check into how this is structured... didn't think we needed a "debounce" on TCP/IP connections.


PUSH sigStartupComplete
{
    integer i; 
    
    if (giRivuletConfigured)
        doRivLinkEnable = ON;
}  
 

 /****************************************************
 This event function processes the incoming messages
 from the Rivulet RCAS server.  
 *****************************************************/
 /////////////////////////////////////////////////////////////////////////////////////////////
 //Note:  This code should now take into account a situation where a second chunk
 //       contains first a ending envelope and then an beginning from next message. 
 /////////////////////////////////////////////////////////////////////////////////////////////
 // JRJ 090728 - added semaphore, boundry checking, moved message processing to separate function
CHANGE RxRivulet
{  
    integer iLen;
	
	if (giRxSemaphore)
	{
	    print ("DEBUG: Enter RxRivulet, Exit due to Semaphore\n");
		return;
	}
	giRxSemaphore = ON; 
	
    //*DEBUG*/ print ("DEBUG: Enter RxRivulet\n");
	
	gsFmRivulet = RxRivulet; 
	clearbuffer(RxRivulet);
   
    // Gather all data in message chunk.
        
    while (gsFmRivulet <> "")
    { 
        iLen = len(gsFmRivulet);
    	if (iLen + len(gsResponseMsg) > MAX_RIVULET_BUFFER)
    	{
    		print("RxRivulet: gsResponseMsg attempted to exceed buffer, data lost\n");
    		gsResponseMsg = right(gsResponseMsg, MAX_RIVULET_BUFFER - iLen) + gsFmRivulet;
    	}
    	else
    		gsResponseMsg = gsResponseMsg + gsFmRivulet;    
    	gsFmRivulet = RxRivulet;
	    clearbuffer(RxRivulet);
    }

	giRxSemaphore = OFF;  
	
    //*DEBUG*/ print ("DEBUG: Exit RxRivulet\n");

} 

// This event parses information passed from ConferenceHub.
// It is used for configuration. 

// INFO - I believe this is initial video setups... based on configuration data received..  
//        Should be able to be tremendously simplified for Rivulet needs...
CHANGE siRivConfig
{
    integer ilinenum, irivnum, itype;
	string sInfo[255];
	string sSplit[255];
	string sName[MAX_ID_LENGTH];
	string stype[5];
	string sdir[2];
	string token[MAX_ID_LENGTH];
	integer index, id, i, j, k, start, count;
	
	sInfo = siRivConfig;
	
	token = Remove(":", sInfo);				// Obtain first word
	token = left(token, len(token) - 1);	// Remove ":"
	sSplit = Remove(":", sInfo);			// Extract Index
	index = atoi(left(sSplit, len(sSplit) - 1));	// Remove ":", make integer

    // if anything is rcv'd rivulet is configured.
	giRivuletConfigured = ON;
	                              
	ilinenum = cmis_eptlist[index].LineCnt + 1;
	irivnum  = giRivuletCount + 1;

   	// Process general line information	
	if (token = "rivulet")
	{ 
		sSplit = Remove(":", sInfo);
		sName  = left(sSplit, len(sSplit) - 1);

		sSplit = Remove(":", sInfo);
		stype  = left(sSplit, len(sSplit) - 1);

		sSplit = Remove(":", sInfo);
		sdir   = left(sSplit, len(sSplit) - 1); 
		       
        if (find("HD", stype))
        {
            if (find ("B", sdir)) 
                itype = ENDPOINT_HVP_BI;
            else if (find ("I", sdir))
                itype = ENDPOINT_HVP_IN;
            else if (find ("O", sdir))
                itype = ENDPOINT_HVP_OUT;
            else
            {
                print("\t\tRIVULET: ep %i-%i, HD, Unsupported direction data\n", index, cmis_eptlist[index].LineCnt);
                return;
            }
        }
        else if (find("SD", stype))
        {
            if (find ("B", sdir)) 
                itype = ENDPOINT_DVP_BI;
            else if (find ("I", sdir))
                itype = ENDPOINT_DVP_IN;
            else if (find ("O", sdir))
                itype = ENDPOINT_DVP_OUT;
            else
            {
                print("\t\tRIVULET: ep %i-%i, SD, Unsupported direction data\n", index, cmis_eptlist[index].LineCnt);
                return;
            }
        }
        else		
		{
            print("\t\tRIVULET: ep %i-%i, Unsupported signal type data\n", index, cmis_eptlist[index].LineCnt);
            return;
		}
		
        //cmis_eptlist[index].Rivulet_eptype[ilinenum] = irivtype;
		
		print("\t\tCMIS-ept=%i, rivulet-ept=%i: %s %s %s\n", index, irivnum, sName, stype, sdir);

  	}	// End of Rivulet information

	else if (token = "RivVEC")
	{ 
		sSplit = Remove(":", sInfo);	            // Extract input start
		sname = left(sSplit, len(sSplit) - 1);     // IP Address

	    itype = ENDPOINT_VEC_IN; 
	    rivulet_eptlist[irivnum].VEC_IP = sname;
    } 
    
    cmis_eptlist[index].CurStatus  = RIVULET_IDLE;
    cmis_eptlist[index].CallActive = OFF;
    cmis_eptlist[index].LineCnt    = ilinenum;
    cmis_eptlist[index].CfgType    = CMIS_YESRIVULET;
    cmis_eptlist[index].Rivulet_epid[ilinenum] = irivnum;

    rivulet_eptlist[irivnum].epname     = sname;
    rivulet_eptlist[irivnum].eptype     = itype;
    rivulet_eptlist[irivnum].cmis_epid  = index;
    rivulet_eptlist[irivnum].cmis_line  = ilinenum;
    rivulet_eptlist[irivnum].CurStatus  = RIVULET_OFFLINE;
    rivulet_eptlist[irivnum].CallActive = OFF; 
    
    giRivuletCount = irivnum;    
    //aoCMIS_epstatus[index] = RIVULET_OFFLINE;

    print("\n\n\n**** CMIS ENDPOINT - BEGIN *****\n"); 
    print("Endpoint: %i\n", index);
    print("Managing %i Rivulet Endpoints\n", cmis_eptlist[index].LineCnt);
    
    for (i = 1 to cmis_eptlist[index].LineCnt) 
    {
        irivnum = cmis_eptlist[index].Rivulet_epid[i];
        print("Rivulet: line=%i, riv_epid=%i, name=%s, type=%i\n", i, irivnum,
                                                       rivulet_eptlist[irivnum].epname,
                                                       rivulet_eptlist[irivnum].eptype);
    }
    print("**** CMIS ENDPOINT - END *****\n"); 
} 



// This event parses information passed from ConferenceHub.
// It is used to initiate routing. 
// INFO - Dynamic Connect/Disconnect information from the rest of our hub control...
CHANGE siVidRoute
{
	string sRoute[255];
	string sSplit[255];
	string token[MAX_ID_LENGTH];
	integer isrc, idst, isrcoff, idstoff, ipriv;
	
	sRoute = siVidRoute;
	
	token = Remove(":", sRoute);			// Obtain first word
	token = left(token, len(token) - 1);	// Remove ":"

	if (token = "enable")	// Connect two rooms for conferencing
	{
		sSplit = Remove(":", sRoute);	// Extract src
		isrc = atoi(left(sSplit, len(sSplit) - 1)); 
	
		sSplit = Remove(":", sRoute);	// Extract dst
		idst = atoi(left(sSplit, len(sSplit) - 1));

		RoutingEnable(isrc, idst);		 
	}
	else if (token = "disable")	// Disconnect two rooms that were in a conference
	{
		sSplit = Remove(":", sRoute);	// Extract src
		isrc = atoi(left(sSplit, len(sSplit) - 1)); 

		sSplit = Remove(":", sRoute);	// Extract dst
		idst = atoi(left(sSplit, len(sSplit) - 1));

		RoutingDisable(isrc, idst);
	}
}

// This is a one-time event automatically called at startup 
// INFO - in the world of Crestron, we do not normally let "main" be the active process,
//        And, in our case, we probably want the TCP/IP connection, once it is
//        established be the main controlling module.
function Main()
{
	integer i, j;

	giRivuletFlag = OFF;
	giRivuletDisconnectFlag = OFF;

    giRivuletConfigured = OFF;
    gsRivuletSessionID = "";
    giRivuletCoorID = 0;
    gsResponseMsg = "";	
           
    giRivuletCount = 0;    //Total number of rivulet endpoints managed.
    
    giRxSemaphore = OFF;
    
    for (i = 1 to MAX_ENDPOINTS)
    {
        aocmis_epstatus[i]    = CMIS_IDLE;
        aorivulet_epstatus[i] = RIVULET_IDLE;
    }

    clear_rivulet_eptlist();
    clear_rivulet_callist();

    clear_cmis_eptlist();
    clear_cmis_callist();
    
    clearResponseList();  

    // Enable I/O   
    WaitForInitializationComplete();

}
