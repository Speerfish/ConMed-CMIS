/*********************************************************************************
  Compiler Directives
  (Uncomment and declare compiler directives as needed)
*********************************************************************************/
// #SYMBOL_NAME ""
// #HINT ""
// #DEFINE_CONSTANT

// INFO - Sample XML Tags...

#DEFINE_CONSTANT XML_MAX_TAGS  		100

#DEFINE_CONSTANT XML_ID_CONFIG  		1
#DEFINE_CONSTANT XML_ID_VERSION  		2
#DEFINE_CONSTANT XML_ID_PRODUCTNAME  	3
#DEFINE_CONSTANT XML_ID_PRODUCTVER  	4
#DEFINE_CONSTANT XML_ID_SITENAME  		5
#DEFINE_CONSTANT XML_ID_CONFIGNUM  		6
#DEFINE_CONSTANT XML_ID_CONFERENCING  	7
#DEFINE_CONSTANT XML_ID_CONFSTART  		8
#DEFINE_CONSTANT XML_ID_CONFACCEPT  	9
#DEFINE_CONSTANT XML_ID_PERMISSION  	10
#DEFINE_CONSTANT XML_ID_ITEM  			11
#DEFINE_CONSTANT XML_ID_TYPE  			12
#DEFINE_CONSTANT XML_ID_CLASS			13
#DEFINE_CONSTANT XML_ID_PORT 			14
#DEFINE_CONSTANT XML_ID_SVIDEOIN  		15
#DEFINE_CONSTANT XML_ID_SVIDEOOUT  		16  

#DEFINE_CONSTANT MAX_ROUTES      4
#DEFINE_CONSTANT MAX_ID_LENGTH  20

//CurRqst values
#DEFINE_CONSTANT RQST_IDLE              0
#DEFINE_CONSTANT RQST_CONNECT           1
#DEFINE_CONSTANT RQST_DISCONNECT        2
#DEFINE_CONSTANT RQST_PORTSTATUS        3

//CurStatus values
//#DEFINE_CONSTANT RIVULET_IDLE           0
//#DEFINE_CONSTANT RIVULET_CONNECTING     1
//#DEFINE_CONSTANT RIVULET_CONNECTED      2
//#DEFINE_CONSTANT RIVULET_DISCONNECTING  3
//#DEFINE_CONSTANT RIVULET_DISCONNECTED   4
//#DEFINE_CONSTANT RIVULET_ERROR          5 

//gsRivuletTimer
#DEFINE_CONSTANT RIVULET_TIMEOUT       75     //15 seconds for connect/disconnect - delay(20) is 200ms 5*15 = 75 

//Connect Type  
#DEFINE_CONSTANT TYPE_NONE              0
#DEFINE_CONSTANT TYPE_HVPTOHVP          1
#DEFINE_CONSTANT TYPE_HVPTOVEC          2

//Endpoint Type
#DEFINE_CONSTANT ENDPOINT_VEC               1
#DEFINE_CONSTANT ENDPOINT_HVP               2 

//XML Receive
#DEFINE_CONSTANT RESPONSE_LIST_MAX         20  

#DEFINE_CONSTANT RIVULET_LOGIN_SUCCESS_MSG              "login-success" 
#DEFINE_CONSTANT RIVULET_GET_PORT_STATUS_MSG            "get-ep-port-alias-status-success" 
#DEFINE_CONSTANT RIVULET_GET_SERVICE_STATUS_MSG         "get-service-status-success"
#DEFINE_CONSTANT RIVULET_CONNECT_SERVICE_FAILURE_MSG    "connect-service-failure"  
#DEFINE_CONSTANT RIVULET_CONNECT_SERVICE_SUCCESS_MSG    "connect-service-success"
#DEFINE_CONSTANT RIVULET_DISCONNECT_SERVICE_FAILURE_MSG "disconnect-service-failure"
#DEFINE_CONSTANT RIVULET_DISCONNECT_SERVICE_SUCCESS_MSG "disconnect-service-success"
//BOOLEAN
#DEFINE_CONSTANT TRUE	1
#DEFINE_CONSTANT FALSE  0

/*********************************************************************************
  Include Libraries
  (Uncomment and include additional librarys as needed)
*********************************************************************************/
// #CRESTRON_LIBRARY ""

#USER_LIBRARY "CMIS_Hub_Library"
#USER_LIBRARY "CMIS_Hub_XML"

/*******************************************************************************************
  DIGITAL, ANALOG and SERIAL INPUTS and OUTPUTS
  (Uncomment and declare inputs and outputs as needed)
*******************************************************************************************/

// Inputs
// DIGITAL_INPUT 

// INFO - DIGITAL inputs can take on the values of 0 or 1.
//        When they go high, it's an event that will start a "process" running.

DIGITAL_INPUT   sigStartupComplete;  //INFO - Event we will use to start "background" task
                                     //       of always-running Rivulet control code. 
DIGITAL_INPUT	sigRivuletConnected; //INFO - Indication of Rivulet TCP/IP connection...
                                     //       Tx/Rx streams will be allowed to go through to the Rivulet control port.
                                     //       If this signal is "low", there is no need to send Tx streams. 

DIGITAL_INPUT   diDebug;

// ANALOG_INPUT  
ANALOG_INPUT    aiRivLinkStatus;

// STRING_INPUT	
STRING_INPUT 	RxRivulet[255];   //INFO - Rivulet Rx Data stream
STRING_INPUT	siRivuletConfig[255];   //INFO - Configuration data for an endpoint should tell us about the two endpoints.
STRING_INPUT	siVidRoute[255];  //INFO - Message rcv'd from Hub call control module when a connection
                                  //       is made or disconnected.

// Outputs
// DIGITAL_OUTPUT 
DIGITAL_OUTPUT  doRivLinkEnable;

// ANALOG_OUTPUT 

// STRING_OUTPUT
STRING_OUTPUT	TxRivulet;       // INFO - Rivulet Tx Data stream

ANALOG_OUTPUT   aoEndpointStatus[MAX_ENDPOINTS];

/*******************************************************************************************
  Structure Definitions
  (Uncomment and define structure definitions as needed)
  Note:  Be sure to initialize all declared STRING variables as needed
         For example, in Function Main: struct.myString = "";
*******************************************************************************************/

// INFO Keep structure for now, don't think we'll need it though...
STRUCTURE VideoEndpoint
{
	INTEGER CustomEndpointID;	// 0 if not a custom endpoint, value 1-4 otherwise.
	INTEGER FixedEndpointID;	// 0 if not a fixed endpoint, value 1-MAX_FIXED_ENDPOINTS otherwise. 

    INTEGER  LineCnt;
    STRING  epname1[20];
    STRING  epname2[20];
    STRING  epname3[20];
    STRING  epname4[20]; 
    INTEGER CurStatus;
    INTEGER CallActive;
    INTEGER Status[4];
	INTEGER SVideoInCount;	
	INTEGER SVideoOutCount;	
	INTEGER SVideoInStart; 
	INTEGer SVideoOutStart; 
	
	INTEGER RivAudioInCnt;
	INTEGER RivAudioOutCnt;
	INTEGER RivDVIInCnt;	
	INTEGER RivDVIOutCnt;	
	INTEGER RivSVideoInCnt;	
	INTEGER RivSVideoOutCnt;	
	INTEGER RivEndpointType;   //HVP or VEC
	STRING  RivVEC_IP[20];     //If VEC, this is the IP Address	
	
	INTEGER Privacy;
}; 

STRUCTURE Connection
{
    INTEGER Room1;        //Endpoint 1
    INTEGER Room2;        //Endpoint 2
    INTEGER CurRqst;      //Connection Request - may be set RQST_CONNECT, or RQST_DISCONNECT by sVidRoute
                          //                     set RQST_IDLE by Rivulet processing. 
    INTEGER CurStatus;    //Rivulet processing Status.  RIVULET_IDLE, RIVULET_CONNECTING, RIVULET_DISCONNECTING...  PG:  RIVULET_ERROR
    INTEGER CurTimer;
    STRING  ErrorString[200];
    INTEGER AudioCnt;
    INTEGER DVICnt;
    INTEGER SVideoCnt;
    INTEGER TYPE; 
    STRING  VEC_IP[20];
    STRING  CorrelationID1[MAX_ID_LENGTH];
    STRING  CorrelationID2[MAX_ID_LENGTH];
    STRING  CorrelationID3[MAX_ID_LENGTH];
    STRING  CorrelationID4[MAX_ID_LENGTH];
    STRING  ServiceID1[MAX_ID_LENGTH]; 
    STRING  ServiceID2[MAX_ID_LENGTH]; 
    STRING  ServiceID3[MAX_ID_LENGTH]; 
    STRING  ServiceID4[MAX_ID_LENGTH]; 
    STRING  ServiceCode1[MAX_ID_LENGTH]; 
    STRING  ServiceCode2[MAX_ID_LENGTH]; 
    STRING  ServiceCode3[MAX_ID_LENGTH]; 
    STRING  ServiceCode4[MAX_ID_LENGTH]; 

}; 

 
STRUCTURE ResponseData
{
    STRING COORELATIONID[20];
    STRING SERVICEID[20];   
    STRING SERVICECODE[20];
    STRING API_CMD_RESP[50];
    STRING API_CMD_ERROR[100];
    STRING ENDPOINT_ALIAS[20]; 
    STRING ENDPOINT_STATUS[20];
    INTEGER INUSE;
};

Connection    ConnectionList[MAX_ENDPOINTS]; 
//INTEGER       ConnectionListStatus[MAX_ENDPOINTS][4];

VideoEndpoint EndpointList[MAX_ENDPOINTS]; 
INTEGER       EndpointStatus[MAX_ENDPOINTS][4];

// Receive 
ResponseData ResponseList[RESPONSE_LIST_MAX];
string gsResponseMsg[1024];    

INTEGER gsRivuletTimer;


/*******************************************************************************************
  Global Variables
*******************************************************************************************/

//-----------------------------------------------------------------------------
// XML Data 

// INFO - normally when CMIS is reading XML, it is data coming from a file
//        that establishes the configuration of our system.  These are
//        used with the xml functions in the usl library file.

string  gsXmlStrings[XML_STRING_ARRAY_SIZE][XML_BUFFER_SIZE];
integer giXmlData[XML_DATA_ARRAY_SIZE];
string  gsXmlParams[4096];
string  gsXmlFileTags[XML_MAX_TAGS][64];  

// INFO - Code I "borrowed" is "debouncing the TCP/IP connection... I need to check on this.
integer giConnectedToRivulet;  // INFO - Rivulet connection status... in case TCP/IP goes down...
integer gInhibitBounce;       // INFO - ok... use this too  
integer giRivuletReady; 
integer giRivuletConfigured;     

// Rivulet Communication Vars
integer giRivuletCoorID;   
string  gsRivuletSessionID[50];

		
/*******************************************************************************************
  Functions
*******************************************************************************************/

/****************************************************
 This function will get the coorelation id for the
 specified connection and dviid.
*****************************************************/

STRING_FUNCTION getConnectionCoorID( integer connectionid, integer dviid )
{  
    string conCoorID[20];
    conCoorID = "";
    
    if ( dviid = 1 )
    {
        conCoorID = ConnectionList[connectionid].CorrelationID1;
    }
    else if ( dviid = 2 )
    {
        conCoorID = ConnectionList[connectionid].CorrelationID2;
    }
    else if ( dviid = 3 )
    {
        conCoorID = ConnectionList[connectionid].CorrelationID3;
    }
    else if ( dviid = 4 )
    { 
        conCoorID = ConnectionList[connectionid].CorrelationID4;
    } 
    return(conCoorID);   
}

 

/****************************************************
 This function will set the coorelation id for the
 specified connection and dviid.
*****************************************************/

function setConnectionCoorID( integer connectionid, integer dviid, string coorid )
{     
    if ( dviid = 1 )
    {
        ConnectionList[connectionid].CorrelationID1 = coorid;
    }
    else if ( dviid = 2 )
    {
        ConnectionList[connectionid].CorrelationID2 = coorid;
    }
    else if ( dviid = 3 )
    {
        ConnectionList[connectionid].CorrelationID3 = coorid;
    }
    else if ( dviid = 4 )
    { 
        ConnectionList[connectionid].CorrelationID4 = coorid;
    } 
} 

/****************************************************
 This function will get the service id for the
 specified connection and dviid.
*****************************************************/

STRING_FUNCTION getConnectionServiceID( integer connectionid, integer dviid )
{ 
    string conServiceID[20];
    conServiceID = "";
    
    if ( dviid = 1 )
    {
        conServiceID = ConnectionList[connectionid].ServiceID1;
    }
    else if ( dviid = 2 )
    {
        conServiceID = ConnectionList[connectionid].ServiceID2;
    }
    else if ( dviid = 3 )
    {
        conServiceID = ConnectionList[connectionid].ServiceID3;
    }
    else if ( dviid = 4 )
    { 
        conServiceID = ConnectionList[connectionid].ServiceID4;
    } 
    return(conServiceID);  
} 

INTEGER_FUNCTION StoreServiceCode(string id, string code)
{
    integer i;
       
    for (i=1 to MAX_ENDPOINTS)
    {
        if (find(id, ConnectionList[i].SERVICEID1))
            ConnectionList[i].SERVICECODE1 = code;
        else if (find(id, ConnectionList[i].SERVICEID2))
            ConnectionList[i].SERVICECODE2 = code;
        else if (find(id, ConnectionList[i].SERVICEID3))
            ConnectionList[i].SERVICECODE3 = code;
        else if (find(id, ConnectionList[i].SERVICEID4))        
            ConnectionList[i].SERVICECODE4 = code;
    }            
}

/****************************************************
 This function will set the service id for the
 specified connection and dviid.
*****************************************************/

function setConnectionServiceID( integer connectionid, integer dviid, string serviceid )
{ 
    if ( dviid = 1 )
    {
        ConnectionList[connectionid].ServiceID1 = serviceid;
    }
    else if ( dviid = 2 )
    {
        ConnectionList[connectionid].ServiceID2 = serviceid;
    }
    else if ( dviid = 3 )
    {
        ConnectionList[connectionid].ServiceID3 = serviceid;
    }
    else if ( dviid = 4 )
    { 
        ConnectionList[connectionid].ServiceID4 = serviceid;
    }   
}   

integer_function StoreServiceID( string corrid, string serviceid)
{
    integer connectionid; 
    integer found;

    found = off;    
    
    for (connectionid = 1 to MAX_ENDPOINTS)
    {
        if (find(corrid, ConnectionList[connectionid].CorrelationID1))
        {
            ConnectionList[connectionid].ServiceID1 = serviceid;
            found = on;
        }
        else if (find(corrid, ConnectionList[connectionid].CorrelationID2))
        {
            ConnectionList[connectionid].ServiceID2 = serviceid;
            found = on;
        }
        else if (find(corrid, ConnectionList[connectionid].CorrelationID3))
        {
            ConnectionList[connectionid].ServiceID3 = serviceid;
            found = on;
        }
        else if (find(corrid, ConnectionList[connectionid].CorrelationID4))
        {
            ConnectionList[connectionid].ServiceID4 = serviceid;
            found = on;
        }
        
        if (found)
            return(connectionid);
    }
    
    return(0);
}    
    


/****************************************************
 This function will send data to the RCAS server over the
 available TCP connection.  This function will split up the
 send into 160 byte chunks as Crestron cannot handle more.
 *****************************************************/
 
function sendData( string xmlData )
{ 
    // Can only send 255 bytes at a time 
    integer length; 
    string sendString[160];
    string tmpString[1024];
    tmpString = xmlData;
    while(1)	
	{
	    length = len(tmpString);
	    if (length > 160)
	    {
	        sendString = RemoveByLength(160, tmpString);
	        TxRivulet = sendString; 
            //* DEBUG */ print( "Sending To Rivulet:  %s len=%d\n", sendString, len(sendString) ); 
            processlogic();            
	    }
	    else
	    {
	        sendstring = tmpstring;
	        TxRivulet = sendString; 
	        //* DEBUG */ print( "Sending Last To Rivulet:  %s\n", sendString );
	        break;
	    }   
	}
}
     
/****************************************************
 This function returns a unique coorelation ID to match 
 Rivulet API requests with Rivulet API responses.
*****************************************************/

STRING_FUNCTION getCoorID()
{
    if ( giRivuletCoorid = 65535 )
    {
        giRivuletCoorid = 1;
    } 
    else
    {
        giRivuletCoorid = giRivuletCoorid + 1; 
    }
    return( itoa( giRivuletCoorid ));
} 

/****************************************************
 This function returns clears out the Endpoint list.
 This is called at system startup.
 *****************************************************/

function ClearEndpoint(integer i)
{
    integer j;
    
    EndpointList[i].CustomEndpointID = 0; 
    EndpointList[i].FixedEndpointID = 0;
		
    EndpointList[i].RivAudioInCnt = 0;
    EndpointList[i].RivAudioOutCnt = 0;
    EndpointList[i].RivDVIInCnt = 0;
    EndpointList[i].RivDVIOutCnt = 0;
    EndpointList[i].RivSVideoInCnt = 0;
    EndpointList[i].RivSVideoOutCnt = 0;
    EndpointList[i].LineCnt = 0;
		
    EndpointList[i].epname1 = "";
    EndpointList[i].epname2 = "";
    EndpointList[i].epname3 = "";
    EndpointList[i].epname4 = "";
		
    EndpointList[i].RivEndpointType = 0;
    EndpointList[i].RivVEC_IP = "";
		
    EndpointList[i].Privacy = 0; 

    EndpointList[i].CurStatus = RIVULET_IDLE; 
    
    for (j = 1 to 4)
        EndpointStatus[i][j] = 0;
} 

function clearEndpointList()
{
    integer i;
    
    for( i = 1 to MAX_ENDPOINTS )
    {  
        ClearEndpoint( i );
    }
 } 

 

/****************************************************
 This function returns clears out the connection list.
 This is called at system startup and when a connection
 to the RCAS server is lost.
 *****************************************************/

function ClearConnection(integer i)
{ 
    integer j;

    aoEndpointStatus[ConnectionList[i].Room1] = RIVULET_IDLE; 
    aoEndpointStatus[ConnectionList[i].Room2] = RIVULET_IDLE; 
    
    ConnectionList[i].Room1 = 0; 				        
    ConnectionList[i].Room2 = 0;        	
    ConnectionList[i].CurRqst = RQST_IDLE;        
    ConnectionList[i].CurStatus = RIVULET_IDLE;    					
    ConnectionList[i].ErrorString = "";
    ConnectionList[i].AudioCnt = 0;
    ConnectionList[i].DVICnt = 0;
    ConnectionList[i].SVideoCnt = 0;
    ConnectionList[i].TYPE = TYPE_NONE; 
    ConnectionList[i].VEC_IP = "";
    ConnectionList[i].CorrelationID1 = "";
    ConnectionList[i].CorrelationID2 = "";
    ConnectionList[i].CorrelationID3 = "";
    ConnectionList[i].CorrelationID4 = "";
    ConnectionList[i].ServiceID1 = ""; 
    ConnectionList[i].ServiceID2 = ""; 
    ConnectionList[i].ServiceID3 = ""; 
    ConnectionList[i].ServiceID4 = ""; 
    ConnectionList[i].ServiceCode1 = ""; 
    ConnectionList[i].ServiceCode2 = ""; 
    ConnectionList[i].ServiceCode3 = ""; 
    ConnectionList[i].ServiceCode4 = ""; 
    
}

function clearConnectionList()
{
    integer i;
    
    for( i = 1 to MAX_ENDPOINTS )
    {  
        ClearConnection( i );
    }
 } 

function clearResponse( integer i )
{
    ResponseList[i].COORELATIONID = "";
    ResponseList[i].SERVICEID = "";
    ResponseList[i].SERVICECODE = "";
    ResponseList[i].API_CMD_RESP = "";
    ResponseList[i].API_CMD_ERROR = "";
    ResponseList[i].ENDPOINT_ALIAS = "";
    ResponseList[i].ENDPOINT_STATUS = "";
    ResponseList[i].INUSE = FALSE;
} 

function clearResponseList()
{ 
    integer i;
    for ( i = 1 to RESPONSE_LIST_MAX )
    {
        ClearResponse(i);
    }
}

INTEGER_FUNCTION getUnusedResponse()
{ 
    integer i;
    for ( i = 1 to RESPONSE_LIST_MAX )
    {
        if ( ResponseList[i].INUSE = FALSE )
        {
            return( i );
        }
    }
    return( 0 );
}

INTEGER_FUNCTION getResponseByCoorID( string coorid )
{
    integer i;
    for ( i = 1 to RESPONSE_LIST_MAX )
    {
        if ( ResponseList[i].COORELATIONID = coorid )
        {
            if (ResponseList[i].INUSE = TRUE) // don't let it be used if the msg has not yet been flagged "in use"
                return( i );
        }
    }
    return( 0 );
}

function ReportConnectionStatus()
{
    integer i;
    integer connectcnt;
    
    for (i = 1 to MAX_ENDPOINTS)
    {
        if (ConnectionList[i].CurStatus = RIVULET_CONNECTED)        
        {       
            if (find("CONNECTED", ConnectionList[i].SERVICECODE1))
                connectcnt = connectcnt + 1;
            if (find("CONNECTED", ConnectionList[i].SERVICECODE2))
                connectcnt = connectcnt + 1;
            if (find("CONNECTED", ConnectionList[i].SERVICECODE3))
                connectcnt = connectcnt + 1;
            if (find("CONNECTED", ConnectionList[i].SERVICECODE4))
                connectcnt = connectcnt + 1;

            if (connectcnt = ConnectionList[i].DVICnt)
            {
                aoEndpointStatus[ConnectionList[i].Room1] = RIVULET_CONNECTED;
                aoEndpointStatus[ConnectionList[i].Room2] = RIVULET_CONNECTED;
            }
            //else if (connectcnt = 0)
            //{
            //    aoEndpointStatus[ConnectionList[i].Room1] = RIVULET_IDLE;
            //    aoEndpointStatus[ConnectionList[i].Room2] = RIVULET_IDLE;
            //}
        }
    }    
}

                
            

/*******************************************************************************************
  Autopatch Functions
  If it writes to TxRivulet, TxRGB, or TxHD, it belongs here
*******************************************************************************************/

// INFO - leaving the functions around as samples...  could be useful...

function EnableSVideo(integer i, integer o)
{
	string outString[16];
	makestring(outString,"CL1I%02dO%02dT",i,o);
	TxRivulet = outString;
	//*DEBUG*/print("SVideo enable %d %d <%s>\n",i,o,outString);
}

//-----------------------------------------------------------------------------

function DisableSVideo(integer o)
{
	string outString[16];
	makestring(outString,"DL1O%02dT",o);
	TxRivulet = outString;
	//*DEBUG*/print("SVideo disable %d, <%s>\n",o,outString);
}

//-----------------------------------------------------------------------------



/*******************************************************************************************
  Routing Functions
*******************************************************************************************/




//-----------------------------------------------------------------------------

function RoutingEnable(integer endpoint1, integer endpoint2)
{
    integer i, availConnection;

    // Don't activate the connection unless at least one endpoint is rivulet.
    if ((EndpointList[endpoint1].RivEndpointType = 0) && (EndpointList[endpoint2].RivEndpointType = 0))
        return;
        
    availConnection = 0;
        
    for (i=1 to MAX_ENDPOINTS)
    {
        if (ConnectionList[i].CurStatus = RIVULET_IDLE) 
        {
            availConnection = i;
            break;
        }
    }
    
    if (availConnection = 0)
    {
        print("No Available connections\n");
        return;                            
    }

    if (EndpointList[endpoint1].RivEndpointType = ENDPOINT_VEC)
    {
        ConnectionList[availConnection].Room1 = endpoint2;
        ConnectionList[availConnection].Room2 = endpoint1;
        ConnectionList[availConnection].Type = TYPE_HVPTOVEC;
    }
    
    else if (EndpointList[endpoint2].RivEndpointType = ENDPOINT_VEC)    
    {
        ConnectionList[availConnection].Room1 = endpoint1;
        ConnectionList[availConnection].Room2 = endpoint2;
        ConnectionList[availConnection].Type = TYPE_HVPTOVEC;
    } 
    
    else
    {
        ConnectionList[availConnection].Room1 = endpoint1;
        ConnectionList[availConnection].Room2 = endpoint2;
        ConnectionList[availConnection].Type = TYPE_HVPTOHVP;
    }
    
    ConnectionList[availConnection].AudioCnt  = EndpointList[endpoint1].RivAudioInCnt;   
    ConnectionList[availConnection].DVICnt    = EndpointList[endpoint1].RivDVIInCnt;   
    ConnectionList[availConnection].SVideoCnt = EndpointList[endpoint1].RivSVideoInCnt;   

    ConnectionList[availConnection].VEC_IP = EndpointList[endpoint1].RivVec_ip;   
    
    ConnectionList[availConnection].CurRqst   = RQST_CONNECT; 

    print("Connection Request submitted to Rivulet, endpoint %i to endpoint %i, Connection id %i\n",
           ConnectionList[availConnection].Room1,
           ConnectionList[availConnection].Room2, availConnection);
}

//-----------------------------------------------------------------------------

function RoutingDisable(integer endpoint1, integer endpoint2)
{
    integer i, CurConnection;

    // Don't deactivate the connection unless at least one endpoint is rivulet.
    if ((EndpointList[endpoint1].RivEndpointType = 0) && (EndpointList[endpoint2].RivEndpointType = 0))
        return;
    
    CurConnection = 0;
        
    for (i=1 to MAX_ENDPOINTS)
        if (ConnectionList[i].CurStatus <> RIVULET_IDLE)
            if ((ConnectionList[i].Room1 = endpoint1) || (ConnectionList[i].Room2 = endpoint1))
            {
                CurConnection = i;
                break;
            }
    
    if (CurConnection = 0)
    {
        print("Connection not found for endpoints %d, %d\n", endpoint1, endpoint2);
    }
    else
    {
        ConnectionList[CurConnection].CurRqst = RQST_DISCONNECT;
            
        print("Connection Disconnect submitted to Rivulet, endpoint %d to endpoint %d, Connection id %d\n", 
           ConnectionList[CurConnection].Room1,
           ConnectionList[CurConnection].Room2, CurConnection);
    }
}

//-----------------------------------------------------------------------------

function InitializeIO()
{
	integer i,j,k;
	integer index;
	integer length;
	integer simCount;
	
	simCount = 0;
	
	// Initialize all room routings
	for (i = 1 to MAX_ENDPOINTS)
	{
		// Initialize SVideo output routes
		index = EndpointList[i].SVideoOutStart;
		length = EndpointList[i].SVideoOutCount;
		if (length)
		{
			print("Hub: Initialize, Endpoint %d, disable svideo %2d through %2d\n",i,index,index + length -1);
			for (j = index to index + length - 1)
			{
			  DisableSVideo(j);
			}
		}

	}

	print("Hub: Video Initialization complete\n");
}  
 

STRING_FUNCTION getAttributeValue( string xmlNodeName, string attributeName, string xml )
 {  
     string tmpstring[1024], tmpnodename[255], rmtmpstring[1024], attributeValue[255];
     integer position,svalpos,evalpos,attrvallen;
     tmpstring = xml;
     tmpnodename = "<" + xmlNodeName;
     position = Find( tmpnodename, tmpstring, 1 );
     // If node is not found get out
     if ( position = 0 ) return( "" );
     position = position + len(tmpnodename);
     rmtmpstring = RemoveByLength( position, tmpstring);
     position = Find( attributeName, tmpstring, 1 ); 
     // Really need to extract ONLY the XML node and then 
     // search. 
     if ( position = 0 ) return ( "" );
     position = Find( "\x22", tmpstring, position );
     svalpos = position;
     position = Find( "\x22", tmpstring, position+1);
     evalpos = position;
     //* DEBUG */ print( "getAttributeValue  svalpos=%d, evalpos=%d, tmpstring=%s\n", svalpos, evalpos, tmpstring);
     attrvallen = evalpos - svalpos - 1; 
     attributeValue = Mid(tmpstring, svalpos+1, attrvallen );
     //* DEBUG */ print( "\n\n\ngetAttributeValue  node=%s, attr=%s, val=%s\n\n\n", xmlNodeName, attributeName, attributeValue ); 
     return( attributeValue );
 }
 

function ProcessRivuletMsg(string smsg)
{   
    integer position; 
    integer responseid; 
    integer endpointid;
    string sessionid[50]; 
    //*DEBUG*/ print("\n\n\n\n\nProcessRivuletMsg: %s\n\n\n\n\n", smsg); 
    
    //Check to see if this is a login request and if so extract session id
    //This will only be called if we do not have a current session id.
    if ( len(gsRivuletSessionID) = 0 )
    {
        position = Find( "login-success", smsg, 1 );
        if ( position != 0 )
        {
            sessionid = getAttributeValue( "binding", "session-id", smsg );
            if ( len(sessionid) != 0 )
            {
                gsRivuletSessionID = sessionid;  
                print("RGM Login Successful\n");
                print("Session ID = %s\n", gsRivuletSessionID );
            }
        }
    }
    else
    {  
        //Get unused response structure from pool
        responseid = getUnusedResponse();
        
        if (responseid = 0) 
        {
            print("WARNING: No room for Rivulet Responses\n");
            return; 
        }
        //We now will take data from each XML response and put it on the receive
        //list for pickup by the connection list procsess thread. 
        ResponseList[responseid].COORELATIONID   = getAttributeValue("correlation","id", smsg ); 
        ResponseList[responseid].API_CMD_RESP    = getAttributeValue("api-cmd-rsp", "rsp", smsg ); 
        ResponseList[responseid].SERVICEID       = getAttributeValue("api-cmd-rsp", "service-id", smsg ); 
        ResponseList[responseid].SERVICECODE     = getAttributeValue("api-cmd-rsp", "service-status-code", smsg);
        ResponseList[responseid].API_CMD_ERROR   = getAttributeValue("api-fault", "fault-detail", smsg );
        ResponseList[responseid].ENDPOINT_ALIAS  = getAttributeValue("api-cmd-rsp", "ep-port-alias-name", smsg );
        ResponseList[responseid].ENDPOINT_STATUS = getAttributeValue("api-cmd-rsp", "ep-port-alias-status-code", smsg );
        
        //*DEBUG*/print( "\n\n\n RespID = %d COORID = %s\n", responseid, ResponseList[responseid].COORELATIONID );
        //*DEBUG*/print( "ServiceID = %s\n", ResponseList[responseid].SERVICEID);
        //*DEBUG*/print( "CMDRESP = %s\n", ResponseList[responseid].API_CMD_RESP );
        //*DEBUG*/print( "CMDERROR = %s\n", ResponseList[responseid].API_CMD_ERROR ); 
        if (diDebug)
        {
            print("\n******BEGIN RGM Response Data**********\n"); 
            print("Response ID = %i\n", responseid);
            print("Correlation ID = %s\n", ResponseList[responseid].COORELATIONID);
            print("api-cmd-rsp = %s\n", ResponseList[responseid].API_CMD_RESP);
            //print("api-cmd-error = %s\n", ResponseList[responseid].API_CMD_ERROR); 
        }
        // perform "DIS" connect checks first, because "CONNECT" msgs are subset of "DISCONNECT" msgs.
        if (find(RIVULET_DISCONNECT_SERVICE_SUCCESS_MSG, ResponseList[responseid].API_CMD_RESP))
        {
            print("*** Rivulet Disconnect Success Msg***\n"); 
        }
        else if (find(RIVULET_DISCONNECT_SERVICE_FAILURE_MSG, ResponseList[responseid].API_CMD_RESP))
        {
            print("*** Rivulet Disconnect Failure Msg: %s***\n", ResponseList[responseid].API_CMD_ERROR); 
        }
        else if (find(RIVULET_CONNECT_SERVICE_SUCCESS_MSG, ResponseList[responseid].API_CMD_RESP))
        {
            print("*** Rivulet Connect Success Msg: Service ID = %s***\n", ResponseList[responseid].SERVICEID); 
        }        
        else if (find(RIVULET_CONNECT_SERVICE_FAILURE_MSG, ResponseList[responseid].API_CMD_RESP))
        {
            print("*** Rivulet Connect Failure Msg: %s***\n", ResponseList[responseid].API_CMD_ERROR); 
        }
        if (diDebug) print("******END RGM Response Data**********\n\n"); 
        ResponseList[responseid].INUSE = TRUE;
    }
}  

/*******************************************************************
 Rivulet XML Send Functions
 *******************************************************************/  

  
 STRING_FUNCTION addXMLHeader( string xmlString )
 {   
     integer contentLength;
     contentLength = Len( xmlString ); 
     xmlString = "Content-Type : text/rivapi\n" +  "Content-Length : " + itoa(contentLength) + "\n\n" + xmlString;
     return(xmlString); 
 }
 
 function sendLoginRequest()
 {   
    string sXMLLogin[4096];  
	string coorid[20];  
 	coorid = getCoorID();
 	sXMLLogin =  "<?xml version=\x221.0\x22 encoding=\x22UTF-8\x22?><api-envelope><api-version version = \x2205.01.00.R002\x22 ></api-version> <correlation id = \x22"
	 + coorid + "\x22 > </correlation> <binding access-method = \x22trusted\x22 ></binding><api-cmd-req req = \x22login\x22 ></api-cmd-req> </api-envelope>"; 
    sXMLLogin = addXMLHeader( sXMLLogin );
    sendData( sXMLLogin ); 
 }   
 
/****************************************************
 This will send a connection request to the RCAS server
 for the number of connections as indicated by the dvicount
 field in the Connection structure.
 
 Note:  Port aliases are automatically generated as follows
 
 HVP Source or Destination:   RM + Room ID + PT + Port ID
 			Example:		  RM1PT2
 			
 VEC Destination:	          RM + The Source RM ID + PT + The Source Port ID + VPV
            Example:          RM1PT2VPV
            
 Keep in mind that when creating a VEC connection this
 is always a unidirectional flow.  VEC also requires
 the IP address of the PC running VEC in order to route
 the video to it.
 *****************************************************/
 
function SendConnectRequest( integer connectionid )
 {   
     string sXMLConnect[1024];  
	 string coorid[20]; 
     integer linecount,i, ep1, ep2; 
     string srcPortAlias[20];
     string dstPortAlias[20];

 	 linecount = ConnectionList[connectionid].DVICnt; 
 	  	 
     if ( ConnectionList[connectionid].TYPE = TYPE_HVPTOHVP  )
     {
        ep1 = ConnectionList[connectionid].Room1;
        ep2 = ConnectionList[connectionid].Room2;
           
        for ( i = 1 to linecount )
        {
            /*DEBUG*/print( "CONNECTING Line=%i\n", i );  
            if (linecount = 1)
            {
                srcPortAlias = EndpointList[ep1].epName1;
                dstPortAlias = EndpointList[ep2].epName1;
            }
            else if (linecount = 2) 
            {
                srcPortAlias = EndpointList[ep1].epName2;
                dstPortAlias = EndpointList[ep2].epName2;
            }
            else if (linecount = 3) 
            {
                srcPortAlias = EndpointList[ep1].epName3;
                dstPortAlias = EndpointList[ep2].epName3;
            }
            else //linecount = 4 
            {
                srcPortAlias = EndpointList[ep1].epName4;
                dstPortAlias = EndpointList[ep2].epName4;
            }
                             
            coorid = getCoorID(); 
            setConnectionCoorID( connectionid,i, coorid ); 
            
            //HALF-DUPLEX OPERATION
            //svc-bidir = true
            //If half duplex was desired, set the parameter above to false...
            //future improvement.
             
            sXMLConnect =  "<?xml version=\x221.0\x22 encoding=\x22UTF-8\x22?><api-envelope><api-version version = \x2205.01.00.R002\x22 > </api-version> " +
            "<correlation id = \x22" + coorid + "\x22 > </correlation> <binding session-id = \x22"+ gsRivuletSessionID + "\x22 > </binding> " +
            "<api-cmd-req req = \x22connect-service\x22 svc-type = \x22dynamic\x22 svc-bidir = \x22true\x22 source-alias = \x22" + 
            srcPortAlias + "\x22 destination-alias = \x22" + dstPortAlias + "\x22 >" +
            "<source-selectors ></source-selectors>" +
			"<destination-selectors ></destination-selectors>" +
			"</api-cmd-req></api-envelope>"; 
            
      	    sXMLConnect = addXMLHeader( sXMLConnect );
            sendData( sXMLConnect );  
        }
     }
     else if ( ConnectionList[connectionid].TYPE = TYPE_HVPTOVEC )
     {  
        ep1 = ConnectionList[connectionid].Room1;
        ep2 = ConnectionList[connectionid].Room2;
        
        //We always assume that for VEC connections that we use DVI src 1
        srcPortAlias = EndpointList[ep1].epName1;
        dstPortAlias = EndpointList[ep2].epName1;

        //srcPortAlias = "RM" + itoa(ConnectionList[connectionid].Room1) + "PT" + itoa(1);
        //dstPortAlias = "RM" + itoa(ConnectionList[connectionid].Room1) + "PT" + itoa(1) + "VPV";
        coorid = getCoorID();
        setConnectionCoorID( connectionid,1, coorid ); 
       	 
        sXMLConnect =  "<?xml version=\x221.0\x22 encoding=\x22UTF-8\x22?><api-envelope><api-version version = \x2205.01.00.R002\x22 > </api-version> " +
        "<correlation id = \x22" + coorid + "\x22 > </correlation> <binding session-id = \x22"+ gsRivuletSessionID + "\x22 > </binding> " +
        "<api-cmd-req req = \x22connect-service\x22 svc-type = \x22dynamic\x22 svc-bidir = \x22false\x22 source-alias = \x22" + 
        srcPortAlias + "\x22 destination-alias = \x22" + dstPortAlias + "\x22 >" +
        "<source-selectors ></source-selectors>" +
	    "<destination-selectors  IP_ADDRESS=\x22" + ConnectionList[connectionid].VEC_IP + "\x22 ></destination-selectors>" +
		"</api-cmd-req></api-envelope>"; 
		//*DEBUG*/print( "\n\n\n VEC CONNECT IP_ADDRESS=%s\n\n", ConnectionList[connectionid].VEC_IP );
        sXMLConnect = addXMLHeader( sXMLConnect );
        sendData( sXMLConnect ); 
     }
     else
     {
         print( "Unsupported Connection Type:  Type = %d\n", ConnectionList[connectionid].TYPE );
     }
 }
 
function SendDisconnectRequest( integer connectionid )
{     
    string sXMLDisconnect[1024]; 
    string coorid[20]; 
    string serviceid[20]; 
    integer i,dvicount; 
    dvicount = ConnectionList[connectionid].DVICnt; 
      
    for ( i = 1 to dvicount )
    {
        coorid = getCoorID(); 
        serviceid = getConnectionServiceID( connectionid, i );
        setConnectionCoorID( connectionid,i, coorid ); 

        /*DEBUG*/print( "Disconnecting Line=%i, Service id=%s\n", i, serviceid );
         
        sXMLDisconnect = "<?xml version=\x221.0\x22 encoding=\x22UTF-8\x22?>"
                           + "<api-envelope>"
                           + "<api-version version = \x2205.01.00.R002\x22 ></api-version>"
                           + " <correlation id = \x22"
	                       + coorid
	                       + "\x22 > </correlation>"
	                       + " <binding session-id = \x22"
	                       + gsRivuletSessionID 
	                       + "\x22 > </binding>"
	                       + " <api-cmd-req req = \x22disconnect-service\x22 service-id = \x22" 
	                       + serviceid
	                       + "\x22></api-cmd-req> </api-envelope>";
        sXMLDisconnect = addXMLHeader( sXMLDisconnect );
        sendData( sXMLDisconnect );  
    }
}      
 
 
function sendPortStatusRequest( integer index )
{     
    string sXMLPortStatus[1024]; 
    string coorid[20]; 
    string serviceid[20]; 
    string PortAlias[20];
    integer i; 

    if (EndpointList[index].RivEndpointType <> ENDPOINT_HVP)    
        return;                                                 

    // Don't query endpoints if a call is active... service query will cover.
    if (EndpointList[i].CallActive = ON)
        return;

    if (EndpointList[index].LineCnt = 0)
        return;
         
    for (i = 1 to EndpointList[index].LineCnt)
    {
        if (i = 1)
            PortAlias = EndpointList[index].epName1;
        else if (i = 2)  
            PortAlias = EndpointList[index].epName2; 
        else if (i = 3)  
            PortAlias = EndpointList[index].epName3; 
        else 
            PortAlias = EndpointList[index].epName4; 
           
        coorid = getCoorID(); 
         
        sXMLPortStatus = "<?xml version=\x221.0\x22 encoding=\x22UTF-8\x22?>"
                   + "<api-envelope>"
                   + "<api-version version = \x2205.01.00.R002\x22 >"
                   + "</api-version>"
                   + " <correlation id = \x22"
                   + coorid 
	               + "\x22 > </correlation>"
	               + " <binding session-id = \x22"
	               + gsRivuletSessionID 
	               + "\x22 > </binding>"
	               + " <api-cmd-req req = \x22get-ep-port-alias-status\x22"  
	               + " ep-port-alias-name = \x22" 
	               + PortAlias 
	               + "\x22></api-cmd-req> </api-envelope>";
        sXMLPortStatus = addXMLHeader( sXMLPortStatus );
        sendData( sXMLPortStatus ); 
    } 
}


function sendServiceStatusRequest( integer index )
{     
    string sXMLPortStatus[1024]; 
    string coorid[20]; 
    string serviceid[20]; 
    string PortAlias[20];
    integer i; 

    print("Send Service Status Request\n");         
    for (i = 1 to ConnectionList[index].DVICnt)
    {
        if (i = 1)
            serviceid = ConnectionList[index].ServiceID1;
        else if (i = 2)  
            serviceid = ConnectionList[index].ServiceID2;
        else if (i = 3)  
            serviceid = ConnectionList[index].ServiceID3;
        else // i = 4
            serviceid = ConnectionList[index].ServiceID4;

        coorid = getCoorID(); 
         
        sXMLPortStatus = "<?xml version=\x221.0\x22 encoding=\x22UTF-8\x22?>"
                   + "<api-envelope>"
                   + "<api-version version = \x2205.01.00.R002\x22 >"
                   + "</api-version>"
                   + " <correlation id = \x22"
                   + coorid 
	               + "\x22 > </correlation>"
	               + " <binding session-id = \x22"
	               + gsRivuletSessionID 
	               + "\x22 > </binding>"
	               + " <api-cmd-req req = \x22get-service-status\x22"  	               
	               + " service-id = \x22" 
	               + serviceid 
	               + "\x22></api-cmd-req> </api-envelope>";
        sXMLPortStatus = addXMLHeader( sXMLPortStatus );
        sendData( sXMLPortStatus ); 
    } 
}       

function ProcessRivuletEndpointStatus(integer index)
{
    integer i, endpoint;

    endpoint = 0;
    
    print("*** Rivulet Endpoint: %s, %s***\n", ResponseList[index].ENDPOINT_ALIAS,
                                               ResponseList[index].ENDPOINT_STATUS);

    for (i=1 to MAX_ENDPOINTS)
    {
        if (find(EndpointList[i].epName1, ResponseList[index].ENDPOINT_ALIAS))
            endpoint = i;
        else
            break;
    }
    if (endpoint)    
        if (find("NOT_AVAILABLE", ResponseList[index].ENDPOINT_STATUS))       
            EndpointList[endpoint].CurStatus = RIVULET_OFFLINE;
        else
            EndpointList[endpoint].CurStatus = RIVULET_IDLE; 
    else
        return;
        
    aoEndpointStatus[endpoint] = EndpointList[endpoint].CurStatus;
                       
}


/*******************************************************************************************
  Events
*******************************************************************************************/
// INFO Need to check into how this is structured... didn't think we needed a "debounce" on TCP/IP connections.

PUSH sigRivuletConnected
{   
    integer i,j, dviid, linecount, rid, gotallresp;
    integer iTimer;
    
    string coorid[10];	 
	print("Connected to RCAS\n");     

	// We are now connected to the RCAS server.  We must send login request.  
	// Wait for a few
	delay(500);
    sendLoginRequest();  

    iTimer = 0;	
    
    while (sigRivuletConnected)
    { 
        iTimer = iTimer + 1;
                     
        for( i = 1 to MAX_ENDPOINTS )
        {
            // Endpoint transaction
            // Send Port query for rivulet endpoints. 
            // Sends the query only if a call is not active for the endpoint.
            if ((iTimer mod 300) = 0)
                sendPortStatusRequest(i);

            // Timer for Connecting/Disconnecting timeouts.            
            if (ConnectionList[i].CurTimer)
                ConnectionList[i].CurTimer = ConnectionList[i].CurTimer - 1;
                        
            if ( ConnectionList[i].CurRqst = RQST_CONNECT )
            { 
                SendConnectRequest( i );
                ConnectionList[i].CurRqst = RQST_IDLE;
                ConnectionList[i].CurStatus = RIVULET_CONNECTING;
                ConnectionList[i].CurTimer = RIVULET_TIMEOUT; 
                aoEndpointStatus[ConnectionList[i].Room1] = RIVULET_CONNECTING; 
                aoEndpointStatus[ConnectionList[i].Room2] = RIVULET_CONNECTING; 
            }
            else if ( ConnectionList[i].CurRqst = RQST_DISCONNECT )
            {  
                SendDisconnectRequest( i );
                ConnectionList[i].CurRqst = RQST_IDLE;
                ConnectionList[i].CurStatus = RIVULET_DISCONNECTING;
                ConnectionList[i].CurTimer = RIVULET_TIMEOUT;  
                aoEndpointStatus[ConnectionList[i].Room1] = RIVULET_DISCONNECTING; 
                aoEndpointStatus[ConnectionList[i].Room2] = RIVULET_DISCONNECTING; 
            }
            else if ( ConnectionList[i].CurStatus = RIVULET_ERROR )
            {
                aoEndpointStatus[ConnectionList[i].Room1] = RIVULET_ERROR; 
                aoEndpointStatus[ConnectionList[i].Room2] = RIVULET_ERROR; 

                // Let Conference Hub initiate the shutdown???
                ClearConnection(i);
            }
            else if ( ConnectionList[i].CurStatus = RIVULET_CONNECTING )
            {
                /*DEBUG*/print( "RIVULET CONNECTING\n");
                gotallresp = TRUE; 
                linecount = ConnectionList[i].DVICnt;
                for ( j = 1 to linecount )
                { 
                    coorid = getConnectionCoorID( i, j );
                    if ( coorid != "" )
                    {
                        //Check to see if we have gotten a response yet.
                        //Note: We might want to put a timeout on waiting
                        //      for a response.  This should not be a 
                        //      problem because if there is no response
                        //      chances are we lost connection to RCAS 
                        //      server.
                        rid = getResponseByCoorID( coorid );
                        if ( rid != 0 )
                        {
                            if (find("failure", ResponseList[rid].API_CMD_RESP))
                            {
                                /*DEBUG*/print( "\n\n\n ***************** CONNECT ERROR *****************\n\n\n");
                                ConnectionList[i].CurStatus = RIVULET_ERROR; 
                                gotallresp = FALSE;
                            }
                            else
                            {                               
                                //Set Service ID
                                setConnectionServiceID( i, j, ResponseList[rid].SERVICEID ); 
                                /*DEBUG*/print( "\n\nCID=%d, RID=%d, DVIID=%d\n", i,rid,j);
                                /*DEBUG*/print( "CONNECTIONLIST SERVICEID1 = %s\n", ConnectionList[i].ServiceID1 );
                                /*DEBUG*/print( "CONNECTIONLIST SERVICEID2 = %s\n", ConnectionList[i].ServiceID2 );
                                /*DEBUG*/print( "CONNECTIONLIST SERVICEID3 = %s\n", ConnectionList[i].ServiceID3 );
                                /*DEBUG*/print( "CONNECTIONLIST SERVICEID4 = %s\n", ConnectionList[i].ServiceID4 );
                            }
                            //Clear Response
                            setConnectionCoorID( i, j, "" );
                            clearResponse( rid );
                        }
                        else
                        { 
                            print("Waiting for connect reply, line %i\n", j);
                            gotallresp = FALSE;
                        }
                    }
                }
                if ( gotallresp = TRUE )
                {
                    // Set Connection to Connected 
                    /*DEBUG*/print( "\n\n\n ***************** CONNECTED *****************\n\n\n");
                    ConnectionList[i].CurStatus = RIVULET_CONNECTED;
                    EndpointList[ConnectionList[i].Room1].CallActive = ON;
                    EndpointList[ConnectionList[i].Room2].CallActive = ON;
                    aoEndpointStatus[ConnectionList[i].Room1] = RIVULET_CONNECTED;
                    aoEndpointStatus[ConnectionList[i].Room2] = RIVULET_CONNECTED;
                } 
                else if (ConnectionList[i].CurTimer = 0)
                {
                    // Timer expire, go to disconnect state.
                    ConnectionList[i].CurRqst = RQST_DISCONNECT;                    
                }

            }
            else if ( ConnectionList[i].CurStatus = RIVULET_DISCONNECTING )
            {   
            	/*DEBUG*/print( "RIVULET DISCONNECTING\n");
                gotallresp = TRUE;
                linecount = ConnectionList[i].DVICnt; 
                for ( j = 1 to linecount )
                {   
                    coorid = getConnectionCoorID( i, j );
                    if ( coorid != "" )
                    {  
                        //Check to see if we have gotten a response yet.
                        rid = getResponseByCoorID( coorid );
                        if ( rid = 0 )
                        {
                            print("Waiting for disconnect reply, line %i\n", j);
                            gotallresp = FALSE;
                        }
                    } 
                } 
                if ( gotallresp = TRUE )
                {
                    for (j = 1 to linecount)
                    {
                        coorid = getConnectionCoorID(i, j);
                        rid = getResponseByCoorID(coorid);
                        clearResponse(rid);
                    }   
                    ConnectionList[i].CurStatus = RIVULET_DISCONNECTED; 

                }
                else if (ConnectionList[i].CurTimer = 0)
                {
                    // Timeout Error during Disconnect
                    ConnectionList[i].CurStatus = RIVULET_ERROR; 
                    /*DEBUG*/print( "\n\n\n ***************** DISCONNECT TIMEOUT ERROR *****************\n\n\n");
                }
            }            
            else if ( ConnectionList[i].CurStatus = RIVULET_DISCONNECTED )
            {   
                // Make sure endpoints are considered available
                EndpointList[ConnectionList[i].Room1].CallActive = OFF;
                EndpointList[ConnectionList[i].Room2].CallActive = OFF; 

                /*DEBUG*/print( "\n\n\n ***************** DISCONNECTED *****************\n\n\n");
                // will set CurStatus to RIVULET_IDLE
                ClearConnection(i);

            }
            
            else if ( ConnectionList[i].CurStatus = RIVULET_CONNECTED )
            { 
                if ((iTimer mod 300) = 0)
                {
                    linecount = ConnectionList[i].DVICnt; 
                    for ( j = 1 to linecount )
                        sendServiceStatusRequest(j);
                } 
            }
             
 
        }

        // Check for Port Status Replies 
        for (i = 1 to RESPONSE_LIST_MAX)
        {
            if (ResponseList[i].INUSE = TRUE)
            {
                if (find(RIVULET_GET_PORT_STATUS_MSG, ResponseList[i].API_CMD_RESP))
                {
                    ProcessRivuletEndpointStatus(i);
                    clearResponse(i);
                } 
                else if (find(RIVULET_GET_SERVICE_STATUS_MSG, ResponseList[i].API_CMD_RESP))
                {
                    print("*** Rivulet Connection: Service ID=%s, Status=%s ***\n",
                               ResponseList[i].SERVICEID,
                               ResponseList[i].SERVICECODE); 
                    
                    StoreServiceCode(ResponseList[i].SERVICEID, ResponseList[i].SERVICECODE);
                    clearResponse(i);                     
                }
            }
        } 
        
        // Report Connection Status by endpoint
        ReportConnectionStatus();
                  

        //delay(100);   Original...
        delay(20);
    } 
}  

RELEASE sigRivuletConnected
{  
	integer i; 
    print("Disconnected from the RCAS\n");  
	// Reset coorelation ID and session ID
	giRivuletCoorID = 0;
	gsRivuletSessionID = "";  
	clearConnectionList();
	clearResponseList();
} 


PUSH sigStartupComplete
{
    integer i; 
    
    if (giRivuletConfigured)
        doRivLinkEnable = ON;
}  

 /****************************************************
 This event function processes the incoming messages
 from the Rivulet RCAS server.  
 *****************************************************/
 /////////////////////////////////////////////////////////////////////////////////////////////
 //Note:  This code does not take into account a situation where a second chunk
 //       contains first a ending envelope and then an beginning from next message. 
 //       (this should not happen as Crestron seems to only process single complete messages)
 /////////////////////////////////////////////////////////////////////////////////////////////
CHANGE RxRivulet
{   
    integer iLen, spos, epos;
	string sFmRivulet[255];
	string sReceiveReturn[1024];

	sFmRivulet = RxRivulet; 
	clearbuffer(RxRivulet);
    iLen = len(sFmRivulet);
    
    // Gather all data in message chunk.    
    while (iLen)
    {
	    sReceiveReturn = sReceiveReturn + sFmRivulet;    
	    sFmRivulet = RxRivulet;
	    clearbuffer(RxRivulet);
	    iLen = len(sFmRivulet);
	} 
    
    // Check if beginning envelope is in chunk
    spos = Find( "<api-envelope>", sReceiveReturn, 1 );
	
	if ( spos != 0 ) // We have chunk with beginning envelope
	{   
	    // Check if ending envelope is in chunk
	    epos = Find( "</api-envelope>", sReceiveReturn, 1 );
	    if ( epos != 0 )
	    {  
	        // Since both are in chunk, we have complete xml, process.
	        ProcessRivuletMsg(sReceiveReturn);
	        gsResponseMsg = "";
	    }
	    else
	    {  
	        //We only have beginning of envelope, set global response and continue.
	        gsResponseMsg = sReceiveReturn;
	    }
	}
	else  // We have chunk w/o beginning envelope
	{  
	    //check if ending envelope is in chunk
	    epos = Find( "</api-envelope>", sReceiveReturn, 1 );
	    if ( epos != 0 )
	    { 
	    	//We found ending envelope. Add to global response, send Process Message and 
	    	//reset global response to empty
	    	gsResponseMsg = gsResponseMsg + sReceiveReturn;
	        ProcessRivuletMsg(gsResponseMsg);
	        gsResponseMsg = ""; 
	    }
	    else
	    { 
	        //We have XML without beginning or end (must be the middle).  
	        //We must add to global response and continue.
	        gsResponseMsg = gsResponseMsg + sReceiveReturn;
	    }
	}
} 

// This event parses information passed from ConferenceHub.
// It is used for configuration. 

// INFO - I believe this is initial video setups... based on configuration data received..  
//        Should be able to be tremendously simplified for Rivulet needs...
CHANGE siRivuletConfig
{
	string sInfo[255];
	string sSplit[255];
	string sName[20];
	string stype[5];
	string sdir[2];
	string token[20];
	integer index, id, i, j, k, start, count;
	
	sInfo = siRivuletConfig;
	
	token = Remove(":", sInfo);				// Obtain first word
	token = left(token, len(token) - 1);	// Remove ":"
	sSplit = Remove(":", sInfo);			// Extract Index
	index = atoi(left(sSplit, len(sSplit) - 1));	// Remove ":", make integer
		
   	// Process SVideo information	
	if (token = "rivulet")
	{ 
	    giRivuletConfigured = ON;
	    
		EndpointList[index].LineCnt = EndpointList[index].LineCnt + 1;
				
		sSplit = Remove(":", sInfo);
		sName  = left(sSplit, len(sSplit) - 1);

		sSplit = Remove(":", sInfo);
		stype  = left(sSplit, len(sSplit) - 1);

		sSplit = Remove(":", sInfo);
		sdir   = left(sSplit, len(sSplit) - 1); 
		
		if (EndpointList[index].LineCnt = 1)
		    EndpointList[index].epname1 = sName;
		else if (EndpointList[index].LineCnt = 2)
		    EndpointList[index].epname2 = sName;
		else if (EndpointList[index].LineCnt = 3)
		    EndpointList[index].epname3 = sName;
		else // LineCnt = 4)
		    EndpointList[index].epname4 = sName;

        if (find("HD", stype))
        {
            if (find ("B", sdir)) 
            {
                print("\t\tRIVULET: ep %i-%i, HD, Bidirectional\n", index, EndpointList[index].LineCnt);
                EndpointList[index].RivDVIInCnt  = EndpointList[index].RivDVIInCnt + 1;
                EndpointList[index].RivDVIOutCnt = EndpointList[index].RivDVIOutCnt + 1;
            }
            else if (find ("I", sdir))
            {
                print("\t\tRIVULET: ep %i-%i, HD, Input only\n", index, EndpointList[index].LineCnt);
                EndpointList[index].RivDVIInCnt = EndpointList[index].RivDVIInCnt + 1; 
            }    
            else if (find ("O", sdir))
            {
                print("\t\tRIVULET: ep %i-%i, HD, Output only\n", index, EndpointList[index].LineCnt);
                EndpointList[index].RivDVIInCnt = EndpointList[index].RivDVIOutCnt + 1; 
            }
            else
            {
                print("\t\tRIVULET: ep %i-%i, HD, Unsupported direction info\n", index, EndpointList[index].LineCnt);
            }
        }
        else if (find("SD", stype))
        {
            if (find ("B", sdir)) 
            {
                print("\t\tRIVULET: ep %i-%i, SD, Bidirectional\n", index, EndpointList[index].LineCnt);
                EndpointList[index].RivSVideoInCnt  = EndpointList[index].RivSVideoInCnt + 1;
                EndpointList[index].RivSVideoOutCnt = EndpointList[index].RivSVideoOutCnt + 1;
            }
            else if (find ("I", sdir))
            {
                print("\t\tRIVULET: ep %i-%i, SD, Input only\n", index, EndpointList[index].LineCnt);
                EndpointList[index].RivSVideoInCnt = EndpointList[index].RivSVideoInCnt + 1; 
            }    
            else if (find ("O", sdir))
            {
                print("\t\tRIVULET: ep %i-%i, SD, Output only\n", index, EndpointList[index].LineCnt);
                EndpointList[index].RivSVideoInCnt = EndpointList[index].RivSVideoOutCnt + 1; 
            }
            else
            {
                print("\t\tRIVULET: ep %i-%i, SD, Unsupported direction info\n", index, EndpointList[index].LineCnt);
            }
        }
        else		
		{
                print("\t\tRIVULET: ep %i-%i, Unsupported signal type info\n", index, EndpointList[index].LineCnt);
		}
		//print("\t\tRIVULET Endpoint %i: %s %s %s\n", index, sName, stype, sdir);

        EndpointList[index].RivEndpointType = ENDPOINT_HVP; // will become Type VEC if VEC IP Address config'd
        EndpointList[index].CurStatus = RIVULET_OFFLINE;
        EndpointList[index].CallActive = OFF;
        aoEndpointStatus[index] = RIVULET_OFFLINE;
	}	// End of Rivulet information

	else if (token = "RivVEC")
	{ 
		sSplit = Remove(":", sInfo);	// Extract input start
		EndpointList[index].RivVEC_IP = left(sSplit, len(sSplit) - 1);

	    EndpointList[index].RivEndpointType = ENDPOINT_VEC;  //HVP or VEC
        EndpointList[index].CurStatus = RIVULET_OFFLINE;
        EndpointList[index].CallActive = OFF;
        aoEndpointStatus[index] = RIVULET_OFFLINE;
    }
} 



// This event parses information passed from ConferenceHub.
// It is used to initiate routing. 
// INFO - Dynamic Connect/Disconnect information from the rest of our hub control...
CHANGE siVidRoute
{
	string sRoute[255];
	string sSplit[255];
	string token[20];
	integer isrc, idst, isrcoff, idstoff, ipriv;
	
	sRoute = siVidRoute;
	
	token = Remove(":", sRoute);			// Obtain first word
	token = left(token, len(token) - 1);	// Remove ":"

	if (token = "enable")	// Connect two rooms for conferencing
	{
		sSplit = Remove(":", sRoute);	// Extract src
		isrc = atoi(left(sSplit, len(sSplit) - 1)); 
	
		sSplit = Remove(":", sRoute);	// Extract dst
		idst = atoi(left(sSplit, len(sSplit) - 1));

		RoutingEnable(isrc, idst);		 
	}
	else if (token = "disable")	// Disconnect two rooms that were in a conference
	{
		sSplit = Remove(":", sRoute);	// Extract src
		isrc = atoi(left(sSplit, len(sSplit) - 1)); 

		sSplit = Remove(":", sRoute);	// Extract dst
		idst = atoi(left(sSplit, len(sSplit) - 1));

		RoutingDisable(isrc, idst);
	}
	else if (token = "mutelocal")
	{
		; // No video changes for this command
	}
}

// This is a one-time event automatically called at startup 
// INFO - in the world of Crestron, we do not normally let "main" be the active process,
//        And, in our case, we probably want the TCP/IP connection, once it is
//        established be the main controlling module.
function Main()
{
	integer i, j;

    giRivuletConfigured = OFF;
    gsRivuletSessionID = "";
    giRivuletCoorID = 0;
    gsResponseMsg = "";	
        
    clearEndpointList();
    clearConnectionList();
    clearResponseList();  

    // Enable I/O   
    WaitForInitializationComplete();

}
